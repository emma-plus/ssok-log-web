<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 분석 파이프라인 - 유사어 분석</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 AI 분석 파이프라인</h1>
            <p>유사어 후보 분석 및 승인/거절 관리 시스템</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API 키</label>
                <input type="password" id="apiKey" placeholder="sk-..." value="">
            </div>

            <div class="input-group">
                <label>분석 데이터 타입</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        단어
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        문장
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API 사용</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        사용
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        사용 안함 (전처리 및 STT 특화 처리만)
                    </label>
                </div>

                <div id="openaiModelOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0;">
                        OpenAI 임베딩 모델 선택
                    </label>
                    <div style="display: flex; flex-direction: row; gap: 5px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-small" checked style="margin-right: 8px;">
                            text-embedding-3-small (기본, 빠름, 경제적)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-large" style="margin-right: 8px;">
                            text-embedding-3-large (더 정확, 느림, 비쌈)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * text-embedding-3-large는 더 높은 정확도를 제공하지만 비용과 처리 시간이 더 많이 소요됩니다.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label>전처리 옵션</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="true" checked style="margin-right: 8px;flex: 1;">
                        전처리 활성화
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="false" style="margin-right: 8px;flex: 1;">
                        전처리 비활성화
                    </label>
                </div>

                <div id="preprocessingStageOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                    <div style="color: #e0e0e0; font-size: 0.9rem; line-height: 1.5; margin-bottom: 15px;">
                        <strong>전처리 단계:</strong><br>
                        <span style="color: #4fc3f7;">Step 1:</span> 한글 숫자 → 아라비아 숫자 (일→1, 이→2, 팔→8 등)<br>
                        <span style="color: #4fc3f7;">Step 2:</span> 소수점 표현 정규화 (점/쩜→., 8점9→8.9)<br>
                        <span style="color: #4fc3f7;">Step 3:</span> 단위 정규화 (m→미터, %→퍼센트, g→그램 등)<br>
                        <span style="color: #4fc3f7;">Step 4:</span> 숫자 → 한글 변환 (8.9→팔점구, 4400→사천사백)<br>
                    </div>

                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <strong>분석할 전처리 단계 선택:</strong>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="original" checked style="margin-right: 8px;">
                            원본 (전처리 없음)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step13" checked style="margin-right: 8px;">
                            1-3단계 (숫자 유지)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step14" checked style="margin-right: 8px;">
                            1-4단계 (한글 변환)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * 선택된 단계들에 대해서만 임베딩을 계산하고 비교합니다. 최소 1개는 선택해야 합니다.
                    </div>
                </div>

                <!-- STT 특화 메트릭 옵션 -->
                <div style="display: flex; align-items: center; margin-top: 15px; padding: 15px; background: #2a2a2a; border-radius: 8px; border-left: 4px solid #4caf50;">
                    <label style="display: flex; align-items: center; font-weight: 600; cursor: pointer;">
                        <input type="checkbox" name="enableSTTMetrics" checked style="margin-right: 12px; transform: scale(1.2);">
                        <span style="color: #4caf50;">🎯 STT 특화 메트릭 활성화</span>
                    </label>
                    <div style="position: relative; margin-left: 10px;">
                        <span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: #4caf50; color: white; border-radius: 50%; font-size: 12px; font-weight: bold; cursor: help;">i</span>
                        <div style="position: absolute; top: 25px; left: -150px; background: #333; color: #e0e0e0; padding: 12px; border-radius: 8px; font-size: 0.85rem; line-height: 1.4; width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; z-index: 1000; border: 1px solid #555;">
                            <strong style="color: #4caf50;">음성 인식 특화 유사도 계산을 추가로 수행합니다:</strong><br><br>
                            • <strong>Jaro-Winkler</strong>: 부분 일치 및 접두사 가중치<br>
                            • <strong>Levenshtein</strong>: 편집 거리 기반 유사도<br>
                            • <strong>Korean Phonetic</strong>: 한국어 음성학적 혼동 패턴 (ㅍ↔ㅋ, ㅌ↔ㄷ 등)<br>
                            • <strong>STT Ensemble</strong>: 임베딩 + STT 메트릭 앙상블 점수
                        </div>
                    </div>
                </div>

                <style>
                .stt-info-container:hover .stt-tooltip {
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                </style>

                <script>
                // STT 정보 아이콘 이벤트는 메인 DOMContentLoaded에서 처리됨
                </script>
            </div>

            <div class="input-group">
                <label for="csvData">분석 데이터 (CSV/TSV 형식)</label>
                <textarea id="csvData" placeholder="단어 형태 - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,스냅드래곤 8,,스냅드래 곰파에&#10;단어 형태 - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		포토		안티&#10;&#10;문장 형태 - TSV: 521	3985	18.5	FALSE	설명	SENTENCE_SIMILARITY_PASS_FAIL_V2	안티딥보이스		원본문장		사용자답변문장"></textarea>
            </div>

            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" onclick="analyzeData()">분석 시작</button>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="debugLevel" style="color: #e0e0e0; font-weight: 600; white-space: nowrap;">로그 레벨:</label>
                    <select id="debugLevel" style="padding: 8px; border: 2px solid #555; border-radius: 8px; background: #3a3a3a; color: #e0e0e0; font-size: 14px;">
                        <option value="0">0: 기본</option>
                        <option value="1" selected>1: 상세</option>
                        <option value="2">2: 모든 로그</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <p>🔄 AI가 데이터를 분석 중입니다...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">모두 승인</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">모두 거절</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6; margin-right: 10px;">JSON 내보내기</button>
                <button class="btn" onclick="exportExcel()" style="background: #2e7d32; margin-right: 10px;">📊 엑셀 내보내기</button>
                <button class="btn" onclick="exportPDF()" style="background: #e91e63;">📄 PDF 내보내기</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- SheetJS 라이브러리 (엑셀 생성용) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- jsPDF 라이브러리 (PDF 생성용) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas 라이브러리 (HTML을 Canvas로 변환) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- config.js 모듈 로드 (키 설정) -->
    <script src="./config.js"></script>
    <!-- similarity.js 모듈 로드 -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js 모듈 로드 -->
    <script src="./preprocessing.js"></script>
    <!-- parser.js 모듈 로드 (데이터 파싱 및 그룹핑) -->
    <script src="./parser.js"></script>
    <!-- management.js 모듈 로드 (관리 기능) -->
    <script src="./management.js"></script>
    <!-- stt-similarity.js 모듈 로드 (STT 특화 유사도) -->
    <script src="./stt-similarity.js"></script>
    <!-- sentence-similarity.js 모듈 로드 (문장 특화 유사도) -->
    <script src="./sentence-similarity.js"></script>
    <!-- displayResults.js 모듈 로드 (결과 표시 및 렌더링) -->
    <script src="./displayResults.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};

        // 디버그 레벨 설정 (0: 기본, 1: 상세, 2: 모든 로그)
        function getDebugLevel() {
            const debugSelect = document.getElementById('debugLevel');
            return debugSelect ? parseInt(debugSelect.value) : 2;
        }

        // 페이지 로드 시 config.js에서 API 키 자동 로드
        document.addEventListener('DOMContentLoaded', function() {
            // STT 정보 아이콘에 hover 이벤트 추가
            const infoIcon = document.querySelector('div[style*="position: relative"] span');
            const tooltip = document.querySelector('div[style*="position: absolute"]');

            if (infoIcon && tooltip) {
                infoIcon.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.visibility = 'visible';
                });

                infoIcon.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    tooltip.style.visibility = 'hidden';
                });
            }

            if (typeof CONFIG !== 'undefined' && CONFIG.OPENAI_API_KEY) {
                document.getElementById('apiKey').value = CONFIG.OPENAI_API_KEY;
                console.log('API 키가 config.js에서 자동으로 로드되었습니다.');
            }

            // 모듈 로딩 상태 확인
            console.log('=== 모듈 로딩 상태 확인 ===');
            console.log('SimilarityCalculator:', typeof SimilarityCalculator !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('STTSimilarity:', typeof STTSimilarity !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('SentenceSimilarity:', typeof SentenceSimilarity !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('TextPreprocessor:', typeof TextPreprocessor !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('DataParser:', typeof DataParser !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('DisplayResults:', typeof DisplayResults !== 'undefined' ? '✅ 로드됨' : '❌ 로드 안됨');
            console.log('==========================');

            if (typeof SentenceSimilarity !== 'undefined') {
                console.log('SentenceSimilarity 메서드들:', Object.keys(SentenceSimilarity));
            }

            // 전처리 옵션 변경 시 단계 선택 표시/숨김
            const preprocessingRadios = document.querySelectorAll('input[name="enablePreprocessing"]');
            const stageOptions = document.getElementById('preprocessingStageOptions');

            function toggleStageOptions() {
                const isEnabled = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
                stageOptions.style.display = isEnabled ? 'block' : 'none';
            }

            preprocessingRadios.forEach(radio => {
                radio.addEventListener('change', toggleStageOptions);
            });

            // OpenAI API 사용 옵션 변경 시 모델 선택 표시/숨김
            const openaiRadios = document.querySelectorAll('input[name="useOpenAI"]');
            const modelOptions = document.getElementById('openaiModelOptions');

            function toggleModelOptions() {
                const isOpenAIEnabled = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
                modelOptions.style.display = isOpenAIEnabled ? 'block' : 'none';
            }

            openaiRadios.forEach(radio => {
                radio.addEventListener('change', toggleModelOptions);
            });

            // 초기 상태 설정
            toggleStageOptions();
            toggleModelOptions();
        });






        // 키워드 유사도 검증 함수 (키워드가 문장에 포함되어 있는지 유사도로 확인)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // 키워드와 문장에서 키워드 부분을 추출하여 비교
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // 문장을 단어로 분리하여 각 단어와 키워드의 유사도 확인
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('키워드 유사도 검증 오류:', error);
                // 오류 시 문자열 포함 여부로 대체
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI 임베딩 API 호출 (단일 텍스트)
        async function getEmbedding(text, apiKey) {
            // todo 일단 주석
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // 더 높은 차원으로 더 정확한 임베딩
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API 오류: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // 텍스트 배열 검증 및 정리 함수
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('유효한 텍스트 배열이 필요합니다.');
            }

            // 1단계: 기본 필터링
            const basicFiltered = texts
                .filter(text => text != null && typeof text === 'string' && text.trim().length > 0);

            // 2단계: 제어 문자 및 특수 문자 정리
            const cleanTexts = basicFiltered.map(text =>
                text.replace(/[\x00-\x1F\x7F]/g, '') // 제어 문자 제거
                .replace(/[^\w\s가-힣]/g, ' ') // 특수 문자를 공백으로 변경
                .trim()
            ).filter(text => text.length > 0);

            // 3단계: 토큰 길이 제한 (OpenAI 제한: 8192 토큰, 대략 8192 문자로 추정)
            const finalTexts = cleanTexts.filter(text =>
                text.length > 0 && text.length < 8192
            );

            if (finalTexts.length === 0) {
                throw new Error('유효한 텍스트가 없습니다.');
            }

            const removed = texts.length - finalTexts.length;
            if (removed > 0) {
                console.warn(`${removed}개의 유효하지 않은 텍스트가 제거되었습니다.`);
                console.log('제거 상세:', {
                    원본: texts.length,
                    기본필터링후: basicFiltered.length,
                    문자정리후: cleanTexts.length,
                    최종: finalTexts.length
                });
            }

            console.log('검증된 텍스트 샘플:', finalTexts.slice(0, 3));
            return finalTexts;
        }

        // 디버깅용 텍스트 배열 분석 함수
        function logTextAnalysis(validTexts) {
            console.log('=== 텍스트 배열 분석 ===');
            console.log('배열 타입:', Array.isArray(validTexts));
            console.log('배열 길이:', validTexts.length);

            // 각 텍스트의 타입과 길이 확인
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('처음 10개 텍스트 분석:', textAnalysis);

            // 빈 문자열이나 문제가 될 수 있는 텍스트 찾기
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('문제가 될 수 있는 텍스트들:', problematicTexts);
            }
            console.log('========================');
        }

        // API 요청 페이로드 로깅 함수
        function logRequestPayload(requestPayload) {
            console.log('API 요청 페이로드 미리보기:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API 오류 로깅 함수
        async function logApiError(response, requestPayload) {
            console.error('API 요청 실패!');
            console.error('응답 상태:', response.status);
            console.error('응답 헤더:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('응답 본문 (텍스트):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('파싱된 오류 데이터:', errorData);
            } catch (parseError) {
                console.error('응답을 JSON으로 파싱할 수 없음:', parseError);
                errorData = { message: errorText };
            }

            // 요청했던 데이터도 함께 로깅
            console.error('실패한 요청의 input 샘플 (처음 3개):', requestPayload.input.slice(0, 3));
            console.error('실패한 요청의 전체 페이로드:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI 임베딩 API 배치 호출 (여러 텍스트를 배치 단위로 나누어 처리)
        async function getBatchEmbeddings(texts, apiKey, selectedModel = 'text-embedding-3-small') {
            // 1. 텍스트 검증 및 정리
            const validTexts = validateAndCleanTexts(texts);

            // 2. 디버깅 로그
            console.log('API를 통해 임베딩 데이터를 로드합니다...');
            console.log(`유효한 텍스트 ${validTexts.length}개:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            if (!validTexts || validTexts.length === 0) {
                throw new Error('전송할 유효한 텍스트가 없습니다.');
            }

            // 3. OpenAI API 배치 크기 제한 (최대 2048개)
            const BATCH_SIZE = 2048;
            const totalBatches = Math.ceil(validTexts.length / BATCH_SIZE);
            const allEmbeddings = [];

            console.log(`총 ${validTexts.length}개 텍스트를 ${totalBatches}개 배치로 나누어 처리합니다.`);

            // 4. 배치별로 순차 처리
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * BATCH_SIZE;
                const endIdx = Math.min(startIdx + BATCH_SIZE, validTexts.length);
                const batchTexts = validTexts.slice(startIdx, endIdx);

                console.log(`배치 ${batchIndex + 1}/${totalBatches}: ${batchTexts.length}개 텍스트 처리 중...`);

                const requestPayload = {
                    model: String(selectedModel).trim(),
                    input: batchTexts.map(String)
                };

                console.log(`배치 ${batchIndex + 1} 요청:`, {
                    모델: requestPayload.model,
                    입력개수: requestPayload.input.length,
                    샘플: requestPayload.input.slice(0, 3)
                });

                try {
                    // API 호출
                    const response = await fetch('https://api.openai.com/v1/embeddings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestPayload)
                    });

                    console.log(`배치 ${batchIndex + 1} API 응답 상태:`, response.status, response.statusText);

                    // 오류 처리
                    if (!response.ok) {
                        const errorData = await logApiError(response, requestPayload);
                        throw new Error(`배치 ${batchIndex + 1} OpenAI API 오류: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    // 성공 응답 처리
                    const data = await response.json();
                    const batchEmbeddings = data.data.map(item => item.embedding);

                    allEmbeddings.push(...batchEmbeddings);
                    console.log(`배치 ${batchIndex + 1} 완료: ${batchEmbeddings.length}개 임베딩 추가 (누적: ${allEmbeddings.length}개)`);

                    // 다음 배치 전에 잠시 대기 (API 레이트 리미트 고려)
                    if (batchIndex < totalBatches - 1) {
                        console.log('다음 배치 처리를 위해 1초 대기...');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                } catch (error) {
                    console.error(`배치 ${batchIndex + 1} 처리 중 오류:`, error);
                    throw error;
                }
            }

            console.log(`모든 배치 처리 완료: 총 ${allEmbeddings.length}개 임베딩 로드`);
            return allEmbeddings;
        }

        // 기존 함수들은 similarity.js로 이동됨

        // 메인 분석 함수
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
            const selectedModel = document.querySelector('input[name="openaiModel"]:checked')?.value || 'text-embedding-3-small';
            const DEBUG_LEVEL = getDebugLevel();

            if (useOpenAI && !apiKey) {
                alert('OpenAI API를 사용하려면 API 키를 입력해주세요.');
                return;
            }

            if (!csvData) {
                alert('분석할 데이터를 입력해주세요.');
                return;
            }

            // 전처리 활성화된 경우 최소 1개 단계 선택 확인
            const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
            if (enablePreprocessing) {
                const selectedStages = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                if (selectedStages.length === 0) {
                    alert('전처리가 활성화된 경우 최소 1개의 단계는 선택해야 합니다.');
                    return;
                }
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. 선택된 타입에 따라 데이터 파싱
                let parsedData;
                if (dataType === 'word') {
                    console.log('단어 데이터 파싱 시작...');
                    parsedData = DataParser.parseWordData(csvData, DEBUG_LEVEL);
                } else if (dataType === 'sentence') {
                    console.log('문장 데이터 파싱 시작...');
                    parsedData = DataParser.parseSentenceData(csvData, DEBUG_LEVEL);
                }
                console.log('파싱된 데이터:', JSON.stringify(parsedData));

                // 2. 선택된 타입에 따라 데이터 그룹핑
                let groupedData;
                if (dataType === 'word') {
                    groupedData = DataParser.groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = DataParser.groupSentenceData(parsedData);
                }
                console.log('그룹핑된 데이터:', JSON.stringify(groupedData));

                // 3. 배치로 임베딩 계산 및 유사도 분석
                analysisResults = [];
                let idCounter = 1;

                // 모든 텍스트를 한 번에 수집
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // 텍스트 유효성 검증 함수
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UI에서 전처리 옵션 가져오기
                const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';

                // 선택된 전처리 단계들 가져오기
                const selectedStages = [];
                if (enablePreprocessing) {
                    const stageCheckboxes = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                    stageCheckboxes.forEach(checkbox => {
                        selectedStages.push(checkbox.value);
                    });

                    // 최소 1개는 선택되어야 함
                    if (selectedStages.length === 0) {
                        alert('전처리가 활성화된 경우 최소 1개의 단계는 선택해야 합니다.');
                        return;
                    }
                } else {
                    selectedStages.push('original'); // 전처리 비활성화 시 원본만
                }

                console.log('전처리 설정:', { enablePreprocessing, selectedStages });

                // 중복 텍스트 관리를 위한 맵 (processedText -> embeddingIndex)
                const uniqueTexts = new Map();
                let duplicateCount = 0;

                //// 선택된 전처리 단계에 따른 텍스트 수집 시작
                /**
                 * 임베딩 생성을 위한 텍스트 수집 과정
                 *
                 * 1. 정답(expected_answer) 텍스트들을 선택된 전처리 단계별로 수집
                 * 2. 각 단계별로 전처리된 텍스트를 allTexts 배열에 추가
                 * 3. textIndexMap으로 나중에 임베딩을 찾을 수 있도록 인덱스 매핑
                 *
                 * 이렇게 수집된 정답 임베딩들은 나중에 사용자 발화와의 유사도 계산에서
                 * 기준점(reference point)으로 사용됨
                 */
                // 정답들을 선택된 단계에 따라 수집
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                console.log(`🔍 디버그: 정답 텍스트 수집 시작 - 총 ${expectedAnswers.length}개 정답`);
                console.log('정답들:', expectedAnswers);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        selectedStages.forEach(stage => {
                            let processedText;
                            let stageKey;

                            if (DEBUG_LEVEL >= 2) {
                                console.log('선택한 단계 stage : ', stage)
                            }

                            // 선택된 전처리 단계에 따라 정답 텍스트 변환
                            switch(stage) {
                                case 'original':
                                    processedText = answer.trim();
                                    stageKey = 'original';
                                    break;
                                case 'step13':
                                    processedText = TextPreprocessor.applyBasePreprocessing(answer.trim());
                                    stageKey = 'step13';
                                    break;
                                case 'step14':
                                    processedText = TextPreprocessor.preprocessLearningText(answer.trim(), DEBUG_LEVEL);
                                    stageKey = 'step14';
                                    break;
                                default:
                                    console.warn(`알 수 없는 전처리 단계: ${stage}`);
                                    return;
                            }

                            const keyMapping = `expected_${answer}_${stageKey}`;

                            // 중복 검사: 이미 동일한 전처리 결과가 있는지 확인
                            if (uniqueTexts.has(processedText)) {
                                // 중복된 텍스트인 경우, 기존 임베딩 인덱스 재사용
                                const existingIndex = uniqueTexts.get(processedText);
                                textIndexMap.set(keyMapping, existingIndex);
                                duplicateCount++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`정답 ${stage} 중복 감지: "${answer}" → "${processedText}" (기존 인덱스 ${existingIndex} 재사용)`);
                                }
                            } else {
                                // 새로운 텍스트인 경우, 임베딩 대상에 추가
                                allTexts.push(processedText);
                                uniqueTexts.set(processedText, textIndex);
                                textIndexMap.set(keyMapping, textIndex);
                                textIndex++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`정답 ${stage} 전처리: "${answer}" → "${processedText}" (새 인덱스 ${textIndex-1})`);
                                }
                            }
                        });
                    } else {
                        console.warn(`유효하지 않은 정답 텍스트:`, answer);
                    }
                });

                console.log('정답들 > 선택된 단계 전처리 적용 완료');

                /**
                 * 사용자 발화(후보) 텍스트들을 선택된 전처리 단계별로 수집
                 *
                 * 1. 각 정답 그룹의 후보들(사용자가 입력한 답변들)을 순회
                 * 2. 정답과 동일한 전처리 단계를 적용하여 공정한 비교 환경 조성
                 * 3. 각 후보의 전처리된 텍스트를 allTexts 배열에 추가
                 * 4. textIndexMap으로 나중에 임베딩을 찾을 수 있도록 인덱스 매핑
                 *
                 * 이렇게 수집된 후보 임베딩들은 나중에 해당 정답 임베딩과의
                 * 유사도(거리/방향) 계산에서 측정 대상으로 사용됨
                 */
                // 모든 후보 단어들도 선택된 단계에 따라 수집
                console.log(`🔍 디버그: 후보 텍스트 수집 시작 - 총 ${groupedData.length}개 그룹`);
                groupedData.forEach((group, groupIndex) => {
                    console.log(`그룹 ${groupIndex + 1}: "${group.expected_answer}" - ${group.candidates.length}개 후보`);
                    group.candidates.forEach((candidate, candidateIndex) => {
                        console.log(`  후보 ${candidateIndex + 1}: "${candidate.candidate_word}"`);
                    });
                });
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            selectedStages.forEach(stage => {
                                let processedText;
                                let stageKey;

                                // 정답과 동일한 전처리 단계를 적용하여 공정한 비교
                                switch(stage) {
                                    case 'original':
                                        processedText = candidate.candidate_word.trim();
                                        stageKey = 'original';
                                        break;
                                    case 'step13':
                                        processedText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word.trim());
                                        stageKey = 'step13';
                                        break;
                                    case 'step14':
                                        processedText = TextPreprocessor.preprocessLearningText(candidate.candidate_word.trim(), DEBUG_LEVEL);
                                        stageKey = 'step14';
                                        break;
                                    default:
                                        console.warn(`알 수 없는 전처리 단계: ${stage}`);
                                        return;
                                }

                                const keyMapping = `candidate_${group.expected_answer}_${candidate.candidate_word}_${stageKey}`;

                                // 중복 검사: 이미 동일한 전처리 결과가 있는지 확인
                                if (uniqueTexts.has(processedText)) {
                                    // 중복된 텍스트인 경우, 기존 임베딩 인덱스 재사용
                                    const existingIndex = uniqueTexts.get(processedText);
                                    textIndexMap.set(keyMapping, existingIndex);
                                    duplicateCount++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`후보 ${stage} 중복 감지: "${candidate.candidate_word}" → "${processedText}" (기존 인덱스 ${existingIndex} 재사용)`);
                                    }
                                } else {
                                    // 새로운 텍스트인 경우, 임베딩 대상에 추가
                                    allTexts.push(processedText);
                                    uniqueTexts.set(processedText, textIndex);
                                    textIndexMap.set(keyMapping, textIndex);
                                    textIndex++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`후보 ${stage} 전처리: "${candidate.candidate_word}" → "${processedText}" (새 인덱스 ${textIndex-1})`);
                                    }
                                }
                            });
                        } else {
                            console.warn(`유효하지 않은 후보 텍스트:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('모든 후보 단어들 > 선택된 단계 전처리 적용 완료');

                // 중복 제거 결과 로그 출력
                const totalRequested = textIndex + duplicateCount;
                console.log(`=== 중복 제거 최적화 결과 ===`);
                console.log(`총 요청된 텍스트: ${totalRequested}개`);
                console.log(`중복 제거된 텍스트: ${duplicateCount}개`);
                console.log(`실제 임베딩 처리 텍스트: ${allTexts.length}개`);
                console.log(`API 호출 절약률: ${(duplicateCount / totalRequested * 100).toFixed(1)}%`);
                console.log('===============================');

                console.log(`총 ${allTexts.length}개 유효한 텍스트를 배치로 임베딩 처리합니다.`);
                console.log('전처리된 텍스트들:', allTexts.slice(0, 10).map((text, i) => `${i}: "${text}"`), allTexts.length > 10 ? `... 외 ${allTexts.length - 10}개` : '');

                // 빈 텍스트가 있는지 최종 확인
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`빈 텍스트 ${emptyTexts.length}개 발견:`, emptyTexts);
                    throw new Error(`유효하지 않은 텍스트가 ${emptyTexts.length}개 포함되어 있습니다.`);
                }

                // 배치 수 미리 계산
                const BATCH_SIZE = 2048; // getBatchEmbeddings와 동일한 값
                const expectedBatches = Math.ceil(allTexts.length / BATCH_SIZE);
                console.log(`=== 임베딩 배치 처리 예상 ===`);
                console.log(`총 텍스트 수: ${allTexts.length}개`);
                console.log(`배치 크기: ${BATCH_SIZE}개`);
                console.log(`예상 배치 수: ${expectedBatches}개`);
                if (expectedBatches > 1) {
                    console.log(`배치별 분할:`);
                    for (let i = 0; i < expectedBatches; i++) {
                        const startIdx = i * BATCH_SIZE;
                        const endIdx = Math.min(startIdx + BATCH_SIZE, allTexts.length);
                        const batchSize = endIdx - startIdx;
                        console.log(`  - 배치 ${i + 1}: ${batchSize}개 (${startIdx + 1}~${endIdx}번째)`);
                    }
                }
                console.log(`예상 처리 시간: 약 ${expectedBatches * 3}초 (배치당 대기시간 포함)`);
                console.log('==============================');

                console.log('전처리된 텍스트들:', allTexts);

                //// 전처리 끝

                // 🔍 디버그: allTexts가 비어있는지 확인
                if (allTexts.length === 0) {
                    console.error('❌ allTexts 배열이 비어있습니다!');
                    console.error('그룹화된 데이터:', groupedData);
                    console.error('선택된 단계:', selectedStages);
                    console.error('데이터 타입:', dataType);
                    throw new Error('처리할 텍스트가 없습니다. 입력 데이터나 전처리 설정을 확인해주세요.');
                }

                // OpenAI API 사용 여부에 따라 분기 처리
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI API를 통한 임베딩 계산
                    console.log(`OpenAI API (${selectedModel})를 통해 임베딩을 계산합니다...`);
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey, selectedModel);
                } else {
                    // OpenAI API 없이 전처리만 수행 - 더미 임베딩 데이터 생성
                    console.log('전처리만 수행합니다. OpenAI API는 사용하지 않습니다.');

                    // 더미 임베딩 데이터 (모든 값이 0.5인 1024차원 벡터)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // console.log('임베딩 결과 = allEmbeddings : ', allEmbeddings)

                /**
                 * 유사도 계산 핵심 로직
                 *
                 * 이 부분이 전체 시스템의 핵심으로, 다음과 같은 과정을 거침:
                 * 1. 정답의 임베딩을 기준점(reference)으로 설정
                 * 2. 사용자 발화(후보)의 임베딩을 측정 대상(target)으로 설정
                 * 3. 두 벡터 간의 거리와 방향을 다양한 유사도 메트릭으로 계산
                 * 4. 가장 높은 유사도를 보이는 전처리 방법을 최적 방법으로 선택
                 *
                 * 유사도 계산 방식:
                 * - 코사인 유사도: 벡터 간의 각도(방향)를 측정 (0~1, 높을수록 유사)
                 * - 유클리디안 거리: 벡터 간의 직선 거리를 측정 (낮을수록 유사)
                 * - 기타 다양한 거리/유사도 메트릭 적용
                 */
                // 각 그룹에 대해 선택된 단계별 유사도 계산
                for (const group of groupedData) {
                    // 각 후보에 대해 유사도 계산
                    for (const candidate of group.candidates) {
                        // 전처리 비교 결과를 저장할 객체
                        candidate.preprocessingComparison = {};

                        // 선택된 각 단계에 대해 유사도 계산
                        const comparisonResults = [];

                        for (const stage of selectedStages) {
                            // 정답의 임베딩 벡터 가져오기 (기준점 역할)
                            const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}_${stage}`)];
                            // 사용자 발화의 임베딩 벡터 가져오기 (측정 대상)
                            const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}_${stage}`)];

                            if (expectedEmbedding && candidateEmbedding) {
                                // 핵심: 정답 임베딩을 기준으로 사용자 발화와의 유사도 계산
                                // expectedEmbedding(기준점) vs candidateEmbedding(측정대상)

                                // STT 메트릭 활성화 여부 확인
                                const enableSTT = document.querySelector('input[name="enableSTTMetrics"]:checked');

                                // 각 단계별 텍스트 생성 (STT 메트릭을 위해 먼저 생성)
                                let expectedText, candidateText;
                                switch(stage) {
                                    case 'original':
                                        expectedText = group.expected_answer;
                                        candidateText = candidate.candidate_word;
                                        break;
                                    case 'step13':
                                        expectedText = TextPreprocessor.applyBasePreprocessing(group.expected_answer);
                                        candidateText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word);
                                        break;
                                    case 'step14':
                                        expectedText = TextPreprocessor.preprocessLearningText(group.expected_answer);
                                        candidateText = TextPreprocessor.preprocessLearningText(candidate.candidate_word);
                                        break;
                                }

                                // 유사도 계산 분기 (데이터 타입별 차별화)
                                let similarities;
                                if (dataType === 'sentence') {
                                    // 🎯 문장 특화 유사도 계산 (향상된 로직)
                                    // SentenceSimilarity 모듈 가용성 확인
                                    if (typeof SentenceSimilarity !== 'undefined' && SentenceSimilarity.calculateSentenceEnhancedSimilarity) {
                                        // 공통 문장 특화 유사도 계산 (OpenAI 사용 여부와 무관)
                                        const sentenceResult = SentenceSimilarity.calculateSentenceEnhancedSimilarity(
                                            expectedEmbedding,
                                            candidateEmbedding,
                                            expectedText,
                                            candidateText,
                                            group.keyword || group.expected_answer
                                        );

                                        if (useOpenAI) {
                                            // OpenAI 사용: 정상적인 문장 특화 유사도 계산
                                            similarities = {
                                                cosine: sentenceResult.finalScore,
                                                euclidean: sentenceResult.components.baseSimilarity || 0.5,
                                                manhattan: sentenceResult.components.keywordWeighted || 0.5,
                                                pearson: sentenceResult.components.sttCorrected || 0.5,
                                                jaccard: sentenceResult.components.completeness || 0.5,

                                                // 문장 특화 메트릭 추가
                                                sentence_enhanced: sentenceResult.finalScore,
                                                sentence_components: sentenceResult.components,
                                                sentence_analysis: sentenceResult.analysis
                                            };
                                        } else {
                                            // OpenAI 미사용: 임베딩 기반 유사도는 0.0으로 설정
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0,

                                                // 문장 특화 메트릭은 유지 (텍스트 기반 계산 포함)
                                                sentence_enhanced: 0.0,
                                                sentence_components: {
                                                    baseSimilarity: 0.0,
                                                    keywordWeighted: 0.0,
                                                    sttCorrected: sentenceResult.components.sttCorrected || 0.0,
                                                    completeness: 0.0,
                                                    lengthPenalty: sentenceResult.components.lengthPenalty || 1.0
                                                },
                                                sentence_analysis: sentenceResult.analysis
                                            };
                                        }

                                        // STT 메트릭이 활성화된 경우 추가
                                        if (enableSTT) {
                                            // STT 앙상블: 단어용 STT 메트릭들의 가중 평균 계산
                                            const sttResult = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                            similarities.stt_ensemble = sttResult.stt_ensemble;

                                            // STT Enhanced: OpenAI 사용 시에만 문장 특화 최종 점수, 미사용 시에는 STT 메트릭 최고값 사용
                                            if (useOpenAI) {
                                                similarities.stt_enhanced = sentenceResult.finalScore;
                                            } else {
                                                // OpenAI 미사용: STT 메트릭들 중 최고값 사용
                                                const sttValues = [
                                                    sttResult.stt_jaro_winkler || 0,
                                                    sttResult.stt_levenshtein || 0,
                                                    sttResult.stt_phonetic || 0
                                                ];
                                                similarities.stt_enhanced = Math.max(...sttValues);
                                            }
                                        }

                                        // ⭐ 키워드 포함 여부 업데이트 (parser.js에서 false로 초기화된 값 수정)
                                        if (sentenceResult.analysis && typeof sentenceResult.analysis.keywordIncluded !== 'undefined') {
                                            candidate.keyword_included = sentenceResult.analysis.keywordIncluded;

                                            if (DEBUG_LEVEL >= 2) {
                                                console.log(`키워드 포함 여부 업데이트: "${candidate.candidate_word}" → keyword_included: ${candidate.keyword_included}`);
                                            }
                                        }

                                        if (DEBUG_LEVEL >= 2) {
                                            console.log(`문장 특화 유사도 계산 완료:`, {
                                                keyword: group.keyword,
                                                finalScore: sentenceResult.finalScore,
                                                components: sentenceResult.components,
                                                analysis: sentenceResult.analysis
                                            });
                                        }
                                    } else {
                                        // SentenceSimilarity 모듈이 없는 경우 기존 방식으로 대체
                                        console.warn('SentenceSimilarity 모듈을 찾을 수 없습니다. 기존 방식을 사용합니다.');
                                        if (enableSTT) {
                                            similarities = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                        } else {
                                            similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);
                                        }
                                    }
                                } else {
                                    // 기존 단어 유사도 계산 로직 유지
                                    if (enableSTT) {
                                        // STT 특화 유사도 계산 (임베딩 + STT 메트릭)
                                        // 💡 STT 메트릭은 텍스트 기반이므로 useOpenAI와 무관하게 작동
                                        if (useOpenAI) {
                                            similarities = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                        } else {
                                            // OpenAI 미사용: 임베딩 기반 유사도는 0.0, STT 메트릭만 계산
                                            const sttOnlyResult = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0,
                                                // STT 메트릭은 유지 (텍스트 기반)
                                                stt_ensemble: sttOnlyResult.stt_ensemble,
                                                stt_enhanced: sttOnlyResult.stt_enhanced,
                                                jaroWinkler: sttOnlyResult.jaroWinkler,
                                                levenshtein: sttOnlyResult.levenshtein,
                                                phonetic: sttOnlyResult.phonetic
                                            };
                                        }
                                    } else {
                                        if (useOpenAI) {
                                            // 기존 방식 (임베딩만)
                                            similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);
                                        } else {
                                            // OpenAI 미사용: 모든 임베딩 기반 유사도 0.0
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0
                                            };
                                        }
                                    }
                                }

                                candidate.preprocessingComparison[stage] = {
                                    similarity: similarities.cosine,
                                    similarities: similarities,
                                    expectedText: expectedText,
                                    candidateText: candidateText
                                };

                                // 문장 데이터의 경우 기존 유사도 메트릭 중 최고값 선택
                                let primarySimilarity = similarities.cosine;
                                if (dataType === 'sentence') {
                                    const basicSimilarityMethods = ['cosine', 'euclidean', 'manhattan', 'pearson', 'jaccard'];
                                    const basicSimilarities = basicSimilarityMethods
                                        .filter(method => similarities[method] !== undefined)
                                        .map(method => ({method, value: similarities[method]}));

                                    if (basicSimilarities.length > 0) {
                                        const highest = basicSimilarities.reduce((max, curr) =>
                                            curr.value > max.value ? curr : max
                                        );
                                        primarySimilarity = highest.value;

                                        if (DEBUG_LEVEL >= 2) {
                                            console.log(`문장 최고 유사도 선택: ${highest.method} = ${highest.value.toFixed(6)}`);
                                        }
                                    }
                                }

                                comparisonResults.push({
                                    name: stage,
                                    similarity: primarySimilarity,
                                    similarities: similarities
                                });

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`${group.expected_answer} vs ${candidate.candidate_word} (${stage}): ${similarities.cosine.toFixed(3)}`);
                                }

                                // 유사도가 너무 낮다면 디버깅 정보 출력
                                if (similarities.cosine < 0.3) {
                                    const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                                    const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                                    console.log(`낮은 유사도 감지 (${stage}):`, {
                                        expected: group.expected_answer,
                                        candidate: candidate.candidate_word,
                                        stage: stage,
                                        similarity: similarities.cosine,
                                        expectedMag: expectedMag.toFixed(6),
                                        candidateMag: candidateMag.toFixed(6)
                                    });
                                }
                            } else {
                                console.warn(`임베딩을 찾을 수 없음: ${stage} 단계`);
                            }
                        }

                        // 가장 높은 유사도를 기본으로 사용
                        if (comparisonResults.length > 0) {
                            const bestComparison = comparisonResults.sort((a, b) => b.similarity - a.similarity)[0];
                            candidate.similarities = bestComparison.similarities;
                            candidate.similarity = bestComparison.similarity;
                            candidate.bestPreprocessingMethod = bestComparison.name;
                        } else {
                            console.warn('유효한 비교 결과가 없습니다.');
                            candidate.similarities = {};
                            candidate.similarity = 0;
                            candidate.bestPreprocessingMethod = 'none';
                        }

                    }

                    // 유사도와 빈도수로 정렬
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // 결과 구조 생성 (문장/단어 타입에 따라 다름)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('결과 데이터:', JSON.stringify(analysisResults));
                // 4. 선택된 타입에 따라 결과 표시
                if (dataType === 'word') {
                    DisplayResults.displayWordResults(analysisResults, approvalStatus);
                } else if (dataType === 'sentence') {
                    DisplayResults.displaySentenceResults(analysisResults, approvalStatus);
                }

            } catch (error) {
                console.error('분석 중 오류:', error);
                document.getElementById('loading').innerHTML = `<div class="error">오류가 발생했습니다: ${error.message}</div>`;
            }
        }


    </script>
</body>
</html>


