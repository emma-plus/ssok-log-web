<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë¶„ì„ íŒŒì´í”„ë¼ì¸ - ìœ ì‚¬ì–´ ë¶„ì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #404040;
        }

        .header h1 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .header p {
            color: #b0b0b0;
            font-size: 1.1rem;
        }

        .input-section {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #404040;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #555;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #4fc3f7;
        }

        .input-group textarea {
            height: 120px;
            resize: vertical;
            font-family: monospace;
        }

        .btn {
            background: #4fc3f7;
            color: #1a1a1a;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #29b6f6;
        }

        .btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #b0b0b0;
        }

        .results-section {
            display: none;
        }

        .result-item {
            background: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid #404040;
        }

        .result-header {
            background: #3a3a3a;
            color: #e0e0e0;
            padding: 20px;
        }

        .result-header h3 {
            margin-bottom: 5px;
        }

        .result-header .expected {
            font-size: 1.2rem;
            font-weight: 600;
            color: #b0b0b0;
        }

        .candidates-list {
            padding: 20px;
        }

        .candidate-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s;
            background: #3a3a3a;
        }

        .candidate-item:hover {
            border-color: #4fc3f7;
            background: #404040;
        }

        .candidate-info {
            flex: 1;
        }

        .candidate-word {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 5px;
        }

        .candidate-stats {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .candidate-actions {
            display: flex;
            gap: 10px;
        }

        .btn-approve {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-approve:hover {
            background: #219a52;
        }

        .btn-reject {
            background: #e74c3c;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-reject:hover {
            background: #c0392b;
        }

        .approved {
            border-color: #4caf50 !important;
            background: #2d4a2d !important;
        }

        .rejected {
            border-color: #f44336 !important;
            background: #4a2d2d !important;
        }

        .similarity-high {
            color: #4caf50;
            font-weight: 600;
        }

        .similarity-medium {
            color: #ff9800;
            font-weight: 600;
        }

        .similarity-low {
            color: #f44336;
            font-weight: 600;
        }

        .similarity-details {
            margin-top: 10px;
            padding: 10px;
            background: #404040;
            border-radius: 5px;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .similarity-method {
            display: inline-block;
            margin: 2px;
            padding: 3px 8px;
            border-radius: 3px;
            background: #555;
            color: #e0e0e0;
        }

        .similarity-method.best {
            background: #4caf50;
            color: white;
        }

        .similarity-method.worst {
            background: #f44336;
            color: white;
        }

        .similarity-toggle {
            background: #666;
            color: #e0e0e0;
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .similarity-toggle:hover {
            background: #777;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– AI ë¶„ì„ íŒŒì´í”„ë¼ì¸</h1>
            <p>ìœ ì‚¬ì–´ í›„ë³´ ë¶„ì„ ë° ìŠ¹ì¸/ê±°ì ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API í‚¤</label>
                <!-- todo test ì„ :: key ì‚­ì œ í•„ìš” -->
                <input type="password" id="apiKey" placeholder="sk-...">
            </div>

            <div class="input-group">
                <label>ë¶„ì„ ë°ì´í„° íƒ€ì…</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        ë‹¨ì–´
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        ë¬¸ì¥
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API ì‚¬ìš©</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš©
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš© ì•ˆí•¨ (ì „ì²˜ë¦¬ë§Œ)
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>ì „ì²˜ë¦¬ ì˜µì…˜</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="enablePreprocessing" checked style="margin-right: 8px;">
                        ì „ì²˜ë¦¬ í™œì„±í™”
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="basicNormalization" checked style="margin-right: 8px;">
                        ê¸°ë³¸ ì •ê·œí™”
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="koreanProcessing" checked style="margin-right: 8px;">
                        í•œêµ­ì–´ ì²˜ë¦¬
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="domainSpecific" checked style="margin-right: 8px;">
                        ë„ë©”ì¸ íŠ¹í™” ì²˜ë¦¬
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label for="domainSelect" style="display: block; margin-bottom: 5px; font-weight: normal;">ë„ë©”ì¸ ì„ íƒ:</label>
                    <select id="domainSelect" style="width: 200px; padding: 5px; background: #3a3a3a; color: #e0e0e0; border: 2px solid #555; border-radius: 4px;">
                        <option value="auto">ìë™ ê°ì§€</option>
                        <option value="learning" selected>í•™ìŠµ (ìˆ«ì/ë‹¨ìœ„)</option>
                        <option value="general">ì¼ë°˜</option>
                        <option value="tech">ê¸°ìˆ </option>
                        <option value="brand">ë¸Œëœë“œ</option>
                    </select>
                </div>
            </div>

            <div class="input-group">
                <label for="csvData">ë¶„ì„ ë°ì´í„° (CSV/TSV í˜•ì‹)</label>
                <textarea id="csvData" placeholder="ë‹¨ì–´ í˜•íƒœ - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,ìŠ¤ëƒ…ë“œë˜ê³¤ 8,,ìŠ¤ëƒ…ë“œë˜ ê³°íŒŒì—&#10;ë‹¨ì–´ í˜•íƒœ - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		í¬í† 		ì•ˆí‹°&#10;&#10;ë¬¸ì¥ í˜•íƒœ - TSV: 521	3985	18.5	FALSE	ì„¤ëª…	SENTENCE_SIMILARITY_PASS_FAIL_V2	ì•ˆí‹°ë”¥ë³´ì´ìŠ¤		ì›ë³¸ë¬¸ì¥		ì‚¬ìš©ìë‹µë³€ë¬¸ì¥"></textarea>
            </div>

            <button class="btn" onclick="analyzeData()">ë¶„ì„ ì‹œì‘</button>
        </div>

        <div class="loading" id="loading">
            <p>ğŸ”„ AIê°€ ë°ì´í„°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">ëª¨ë‘ ìŠ¹ì¸</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">ëª¨ë‘ ê±°ì ˆ</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6;">ê²°ê³¼ ë‚´ë³´ë‚´ê¸°</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- similarity.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./preprocessing.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};

        // CSV/TSV ë‹¨ì–´ ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜
        function parseWordData(dataText) {
            const lines = dataText.trim().split('\n');
            const data = [];

            // ì¹´ìš´í„° ë³€ìˆ˜ë“¤
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // ë°ì´í„° í˜•íƒœ ìë™ ê°ì§€ (ì²« ë²ˆì§¸ ìœ íš¨í•œ ë¼ì¸ìœ¼ë¡œ íŒë‹¨)
            let delimiter = ','; // ê¸°ë³¸ê°’ì€ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // íƒ­ê³¼ ì‰¼í‘œ ê°œìˆ˜ë¥¼ ì„¸ì–´ì„œ ë” ë§ì€ ìª½ìœ¼ë¡œ ê²°ì •
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } else {
                        delimiter = ',';
                        console.log('CSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ë¹ˆ ì¤„ ì²´í¬
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // ì£¼ì„ ë¼ì¸ ì²´í¬
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`ì£¼ì„ ë¼ì¸ ê±´ë„ˆë›°ê¸°: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        answer: parts[7].trim(),
                        user_answer: parts[9].trim()
                    });
                } else {
                    skippedInvalidLines++;
                    console.log(`ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸ (ì»¬ëŸ¼ ìˆ˜ ë¶€ì¡±): ${trimmedLine}`);
                }
            }

            console.log('=== íŒŒì‹± ê²°ê³¼ ìš”ì•½ ===');
            console.log(`ì „ì²´ ë¼ì¸ ìˆ˜: ${totalLines}`);
            console.log(`ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ëœ ë ˆì½”ë“œ: ${data.length}`);
            console.log(`ê±´ë„ˆë›´ ë¹ˆ ì¤„: ${skippedEmptyLines}`);
            console.log(`ê±´ë„ˆë›´ ì£¼ì„ ë¼ì¸: ${skippedCommentLines}`);
            console.log(`ê±´ë„ˆë›´ ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸: ${skippedInvalidLines}`);
            console.log(`ì‚¬ìš©ëœ êµ¬ë¶„ì: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // CSV/TSV ë¬¸ì¥ ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜
        function parseSentenceData(dataText) {
            const lines = dataText.trim().split('\n');
            const data = [];

            // ì¹´ìš´í„° ë³€ìˆ˜ë“¤
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // ë°ì´í„° í˜•íƒœ ìë™ ê°ì§€ (ì²« ë²ˆì§¸ ìœ íš¨í•œ ë¼ì¸ìœ¼ë¡œ íŒë‹¨)
            let delimiter = ','; // ê¸°ë³¸ê°’ì€ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // íƒ­ê³¼ ì‰¼í‘œ ê°œìˆ˜ë¥¼ ì„¸ì–´ì„œ ë” ë§ì€ ìª½ìœ¼ë¡œ ê²°ì •
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } else {
                        delimiter = ',';
                        console.log('CSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ë¹ˆ ì¤„ ì²´í¬
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // ì£¼ì„ ë¼ì¸ ì²´í¬
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`ì£¼ì„ ë¼ì¸ ê±´ë„ˆë›°ê¸°: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                // ë¬¸ì¥ ë°ì´í„°ëŠ” ìµœì†Œ 10ê°œ ì»¬ëŸ¼ì´ í•„ìš” (id, user_id, version, judge, description, type, keyword, empty, original_sentence, user_sentence)
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        version: parts[2].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        description: parts[4].trim(),
                        type: parts[5].trim(),
                        keyword: parts[6].trim(),
                        empty1: parts[7].trim(),
                        answer: parts[8].trim(), // ì›ë³¸ ë¬¸ì¥
                        user_answer: parts[9].trim() // ì‚¬ìš©ì ë‹µë³€ ë¬¸ì¥
                    });
                } else {
                    skippedInvalidLines++;
                    console.log(`ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸ (ì»¬ëŸ¼ ìˆ˜ ë¶€ì¡±): ${trimmedLine}`);
                }
            }

            console.log('=== ë¬¸ì¥ ë°ì´í„° íŒŒì‹± ê²°ê³¼ ìš”ì•½ ===');
            console.log(`ì „ì²´ ë¼ì¸ ìˆ˜: ${totalLines}`);
            console.log(`ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ëœ ë ˆì½”ë“œ: ${data.length}`);
            console.log(`ê±´ë„ˆë›´ ë¹ˆ ì¤„: ${skippedEmptyLines}`);
            console.log(`ê±´ë„ˆë›´ ì£¼ì„ ë¼ì¸: ${skippedCommentLines}`);
            console.log(`ê±´ë„ˆë›´ ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸: ${skippedInvalidLines}`);
            console.log(`ì‚¬ìš©ëœ êµ¬ë¶„ì: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // ë‹¨ì–´ ë°ì´í„°ë¥¼ ê·¸ë£¹í•‘í•˜ëŠ” í•¨ìˆ˜ (expected_answerë³„ë¡œ ê·¸ë£¹í•‘)
        function groupWordData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer) continue;

                const key = row.answer;
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        candidates: []
                    };
                }

                // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ ê¸°ì¡´ í›„ë³´ ì¤‘ì—ì„œ ê°™ì€ user_answerê°€ ìˆëŠ”ì§€ í™•ì¸
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        similarity: 0, // ì„ë² ë”© ê³„ì‚° í›„ ì—…ë°ì´íŠ¸
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // ë¬¸ì¥ ë°ì´í„°ë¥¼ ê·¸ë£¹í•‘í•˜ëŠ” í•¨ìˆ˜ (í‚¤ì›Œë“œë³„ë¡œ ê·¸ë£¹í•‘)
        function groupSentenceData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer || !row.keyword) continue;

                const key = row.keyword; // í‚¤ì›Œë“œë¡œ ê·¸ë£¹í•‘
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        keyword: row.keyword,
                        candidates: []
                    };
                }

                // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ ê¸°ì¡´ í›„ë³´ ì¤‘ì—ì„œ ê°™ì€ user_answerê°€ ìˆëŠ”ì§€ í™•ì¸
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        keyword: row.keyword,
                        keyword_included: false, // í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ (ë‚˜ì¤‘ì— ê³„ì‚°)
                        similarity: 0, // ì„ë² ë”© ê³„ì‚° í›„ ì—…ë°ì´íŠ¸
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ í•¨ìˆ˜ (í‚¤ì›Œë“œê°€ ë¬¸ì¥ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ìœ ì‚¬ë„ë¡œ í™•ì¸)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // í‚¤ì›Œë“œì™€ ë¬¸ì¥ì—ì„œ í‚¤ì›Œë“œ ë¶€ë¶„ì„ ì¶”ì¶œí•˜ì—¬ ë¹„êµ
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // ë¬¸ì¥ì„ ë‹¨ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ê° ë‹¨ì–´ì™€ í‚¤ì›Œë“œì˜ ìœ ì‚¬ë„ í™•ì¸
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ ì˜¤ë¥˜:', error);
                // ì˜¤ë¥˜ ì‹œ ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ë¡œ ëŒ€ì²´
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI ì„ë² ë”© API í˜¸ì¶œ (ë‹¨ì¼ í…ìŠ¤íŠ¸)
        async function getEmbedding(text, apiKey) {
            // todo ì¼ë‹¨ ì£¼ì„
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // ë” ë†’ì€ ì°¨ì›ìœ¼ë¡œ ë” ì •í™•í•œ ì„ë² ë”©
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API ì˜¤ë¥˜: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // í…ìŠ¤íŠ¸ ë°°ì—´ ê²€ì¦ ë° ì •ë¦¬ í•¨ìˆ˜
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ ë°°ì—´ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            }

            const validTexts = texts.filter(text => text && typeof text === 'string' && text.trim().length > 0);

            if (validTexts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            if (validTexts.length !== texts.length) {
                console.warn(`${texts.length - validTexts.length}ê°œì˜ ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            }

            return validTexts;
        }

        // ë””ë²„ê¹…ìš© í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ í•¨ìˆ˜
        function logTextAnalysis(validTexts) {
            console.log('=== í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ ===');
            console.log('ë°°ì—´ íƒ€ì…:', Array.isArray(validTexts));
            console.log('ë°°ì—´ ê¸¸ì´:', validTexts.length);

            // ê° í…ìŠ¤íŠ¸ì˜ íƒ€ì…ê³¼ ê¸¸ì´ í™•ì¸
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('ì²˜ìŒ 10ê°œ í…ìŠ¤íŠ¸ ë¶„ì„:', textAnalysis);

            // ë¹ˆ ë¬¸ìì—´ì´ë‚˜ ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ì°¾ê¸°
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ë“¤:', problematicTexts);
            }
            console.log('========================');
        }

        // API ìš”ì²­ í˜ì´ë¡œë“œ ë¡œê¹… í•¨ìˆ˜
        function logRequestPayload(requestPayload) {
            console.log('API ìš”ì²­ í˜ì´ë¡œë“œ ë¯¸ë¦¬ë³´ê¸°:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API ì˜¤ë¥˜ ë¡œê¹… í•¨ìˆ˜
        async function logApiError(response, requestPayload) {
            console.error('API ìš”ì²­ ì‹¤íŒ¨!');
            console.error('ì‘ë‹µ ìƒíƒœ:', response.status);
            console.error('ì‘ë‹µ í—¤ë”:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('ì‘ë‹µ ë³¸ë¬¸ (í…ìŠ¤íŠ¸):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('íŒŒì‹±ëœ ì˜¤ë¥˜ ë°ì´í„°:', errorData);
            } catch (parseError) {
                console.error('ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŒ:', parseError);
                errorData = { message: errorText };
            }

            // ìš”ì²­í–ˆë˜ ë°ì´í„°ë„ í•¨ê»˜ ë¡œê¹…
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ input ìƒ˜í”Œ (ì²˜ìŒ 3ê°œ):', requestPayload.input.slice(0, 3));
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ ì „ì²´ í˜ì´ë¡œë“œ:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI ì„ë² ë”© API ë°°ì¹˜ í˜¸ì¶œ (ì—¬ëŸ¬ í…ìŠ¤íŠ¸ í•œ ë²ˆì—)
        async function getBatchEmbeddings(texts, apiKey) {


            // // // todo temp - embedding // word_under70_yellow_false.csv
            // // // console.log('embedding_response_word_under70_yellow_false.txt íŒŒì¼ì—ì„œ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            // // // // embedding_response.txt íŒŒì¼ì—ì„œ ë°ì´í„° ë¡œë“œ
            // // // const response = await fetch('./embedding_response_word_under70_yellow_false.txt');
            // //
            // // // console.log('embedding_response_word_under70_yellow_true.txt íŒŒì¼ì—ì„œ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            // // // const response = await fetch('./embedding_response_word_under70_yellow_true.txt');
            // //
            // console.log('embding_8inch.txt íŒŒì¼ì—ì„œ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            // const response = await fetch('./embding_8inch.txt');


            // todo openai - embedding /
            // todo ì „ì²˜ë¦¬ë¥¼ ì¶”ê°€í–ˆìœ¼ë‹ˆ, ì „ì²´ ë°ì´í„°ë¥¼ ë„£ê³ , ë¶„ì„ ë°ì´í„°ë¥¼ ë½‘ì•„ë³´ì!!

            // 1. í…ìŠ¤íŠ¸ ê²€ì¦ ë° ì •ë¦¬
            const validTexts = validateAndCleanTexts(texts);

            // 2. ë””ë²„ê¹… ë¡œê·¸
            console.log('APIë¥¼ í†µí•´ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            console.log(`ìœ íš¨í•œ í…ìŠ¤íŠ¸ ${validTexts.length}ê°œ:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            // 3. API ìš”ì²­ ì¤€ë¹„
            const requestPayload = {
                model: 'text-embedding-3-small',
                input: validTexts,
                dimensions: 1024
            };

            logRequestPayload(requestPayload);

            // 4. API í˜¸ì¶œ
            const response = await fetch('https://api.openai.com/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(requestPayload)
            });

            console.log('API ì‘ë‹µ ìƒíƒœ:', response.status, response.statusText);

            // 5. ì˜¤ë¥˜ ì²˜ë¦¬
            if (!response.ok) {
                const errorData = await logApiError(response, requestPayload);
                throw new Error(`OpenAI API ì˜¤ë¥˜: ${response.status} - ${JSON.stringify(errorData)}`);
            }
            /////////

            // 6. ì„±ê³µ ì‘ë‹µ ì²˜ë¦¬
            const data = await response.json();
            console.log(`${data.data.length}ê°œì˜ ì„ë² ë”©ì„ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.`);
            return data.data.map(item => item.embedding);
        }

        // ê¸°ì¡´ í•¨ìˆ˜ë“¤ì€ similarity.jsë¡œ ì´ë™ë¨

        // ë©”ì¸ ë¶„ì„ í•¨ìˆ˜
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';

            if (useOpenAI && !apiKey) {
                alert('OpenAI APIë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!csvData) {
                alert('ë¶„ì„í•  ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° íŒŒì‹±
                let parsedData;
                if (dataType === 'word') {
                    console.log('ë‹¨ì–´ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = parseWordData(csvData);
                } else if (dataType === 'sentence') {
                    console.log('ë¬¸ì¥ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = parseSentenceData(csvData);
                }
                console.log('íŒŒì‹±ëœ ë°ì´í„°:', JSON.stringify(parsedData));

                // 2. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° ê·¸ë£¹í•‘
                let groupedData;
                if (dataType === 'word') {
                    groupedData = groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = groupSentenceData(parsedData);
                }
                console.log('ê·¸ë£¹í•‘ëœ ë°ì´í„°:', JSON.stringify(groupedData));

                // 3. ë°°ì¹˜ë¡œ ì„ë² ë”© ê³„ì‚° ë° ìœ ì‚¬ë„ ë¶„ì„
                analysisResults = [];
                let idCounter = 1;

                // ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ í•œ ë²ˆì— ìˆ˜ì§‘
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // í…ìŠ¤íŠ¸ ìœ íš¨ì„± ê²€ì¦ í•¨ìˆ˜
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UIì—ì„œ ì „ì²˜ë¦¬ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
                const enablePreprocessing = document.getElementById('enablePreprocessing').checked;
                const preprocessingOptions = {
                    numericNormalization: true, // STT ìˆ«ì í‘œí˜„ ì •ê·œí™” í•­ìƒ í™œì„±í™”
                    normalize: document.getElementById('basicNormalization').checked,
                    korean: document.getElementById('koreanProcessing').checked,
                    clean: document.getElementById('basicNormalization').checked, // ê¸°ë³¸ ì •ê·œí™”ì— í¬í•¨
                    domainProcessing: document.getElementById('domainSpecific').checked,
                    domain: document.getElementById('domainSelect').value === 'auto' ? null : document.getElementById('domainSelect').value,
                    debug: true // ë””ë²„ê¹… í™œì„±í™”ë¡œ ì „ì²˜ë¦¬ ê³¼ì • í™•ì¸
                };

                console.log('ì „ì²˜ë¦¬ ì„¤ì •:', { enablePreprocessing, ...preprocessingOptions });

                // todo --- ì—¬ê¸° ì´ì–´ì„œ ì§„í–‰


                //// ì „ì²˜ë¦¬ ì‹œì‘
                // ì •ë‹µë“¤ ë¨¼ì € ìˆ˜ì§‘ (ì „ì²˜ë¦¬ ì ìš©)
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        const preprocessedAnswer = enablePreprocessing ?
                            TextPreprocessor.preprocessText(answer.trim(), preprocessingOptions) :
                            answer.trim();

                        // ì „ì²˜ë¦¬ í›„ì—ë„ ìœ íš¨í•œì§€ ì¬í™•ì¸
                        if (isValidText(preprocessedAnswer)) {
                            allTexts.push(preprocessedAnswer);
                            textIndexMap.set(`expected_${answer}`, textIndex++);
                        } else {
                            console.warn(`ì „ì²˜ë¦¬ í›„ ë¹ˆ í…ìŠ¤íŠ¸ê°€ ë¨:`, answer, 'â†’', preprocessedAnswer);
                            // ì „ì²˜ë¦¬ ì—†ì´ ì›ë³¸ ì‚¬ìš©
                            allTexts.push(answer.trim());
                            textIndexMap.set(`expected_${answer}`, textIndex++);
                        }
                    } else {
                        console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì •ë‹µ í…ìŠ¤íŠ¸:`, answer);
                    }
                });

                console.log('ì •ë‹µë“¤ > ì „ì²˜ë¦¬ ì ìš©:', { ...allTexts });

                // ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ ìˆ˜ì§‘ (ì „ì²˜ë¦¬ ì ìš©)
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            const preprocessedCandidate = enablePreprocessing ?
                                TextPreprocessor.preprocessText(candidate.candidate_word.trim(), preprocessingOptions) :
                                candidate.candidate_word.trim();

                            // ì „ì²˜ë¦¬ í›„ì—ë„ ìœ íš¨í•œì§€ ì¬í™•ì¸
                            if (isValidText(preprocessedCandidate)) {
                                allTexts.push(preprocessedCandidate);
                                textIndexMap.set(`candidate_${group.expected_answer}_${candidate.candidate_word}`, textIndex++);
                            } else {
                                console.warn(`ì „ì²˜ë¦¬ í›„ ë¹ˆ í…ìŠ¤íŠ¸ê°€ ë¨:`, candidate.candidate_word, 'â†’', preprocessedCandidate);
                                // ì „ì²˜ë¦¬ ì—†ì´ ì›ë³¸ ì‚¬ìš©
                                allTexts.push(candidate.candidate_word.trim());
                                textIndexMap.set(`candidate_${group.expected_answer}_${candidate.candidate_word}`, textIndex++);
                            }
                        } else {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ í›„ë³´ í…ìŠ¤íŠ¸:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ > ì „ì²˜ë¦¬ ì ìš©:', { ...allTexts });

                console.log(`ì´ ${allTexts.length}ê°œ ìœ íš¨í•œ í…ìŠ¤íŠ¸ë¥¼ ë°°ì¹˜ë¡œ ì„ë² ë”© ì²˜ë¦¬í•©ë‹ˆë‹¤.`);

                // ë¹ˆ í…ìŠ¤íŠ¸ê°€ ìˆëŠ”ì§€ ìµœì¢… í™•ì¸
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`ë¹ˆ í…ìŠ¤íŠ¸ ${emptyTexts.length}ê°œ ë°œê²¬:`, emptyTexts);
                    throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ${emptyTexts.length}ê°œ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
                }

                //// ì „ì²˜ë¦¬ ë

                // OpenAI API ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI APIë¥¼ í†µí•œ ì„ë² ë”© ê³„ì‚°
                    console.log('OpenAI APIë¥¼ í†µí•´ ì„ë² ë”©ì„ ê³„ì‚°í•©ë‹ˆë‹¤...');
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey);
                } else {
                    // OpenAI API ì—†ì´ ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰ - ë”ë¯¸ ì„ë² ë”© ë°ì´í„° ìƒì„±
                    console.log('ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤. OpenAI APIëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    console.log('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë“¤:', allTexts);

                    // ë”ë¯¸ ì„ë² ë”© ë°ì´í„° (ëª¨ë“  ê°’ì´ 0.5ì¸ 1024ì°¨ì› ë²¡í„°)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // ê° ê·¸ë£¹ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                for (const group of groupedData) {
                    const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}`)];

                    // ê° í›„ë³´ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                    for (const candidate of group.candidates) {
                        const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}`)];

                        // ë‹¤ì–‘í•œ ìœ ì‚¬ë„ ê³„ì‚° ë°©ë²• ì‚¬ìš©
                        const similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);

                        // ê° ìœ ì‚¬ë„ ê²°ê³¼ë¥¼ ì €ì¥
                        candidate.similarities = similarities;

                        // ê¸°ë³¸ ìœ ì‚¬ë„ëŠ” ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ì‚¬ìš© (ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€)
                        candidate.similarity = similarities.cosine;

                        // todo test - checkKeywordSimilarity ì¼ë‹¨ íŒ¨ìŠ¤
                        // // ë¬¸ì¥ íƒ€ì…ì¸ ê²½ìš° í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ í™•ì¸
                        // if (dataType === 'sentence' && candidate.keyword) {
                        //     candidate.keyword_included = await checkKeywordSimilarity(candidate.keyword, candidate.candidate_word, apiKey);
                        // }

                        // ìœ ì‚¬ë„ê°€ ë„ˆë¬´ ë‚®ë‹¤ë©´ ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
                        if (candidate.similarity < 0.3) {
                            const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                            const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                            console.log(`ë‚®ì€ ìœ ì‚¬ë„ ê°ì§€:`, {
                                expected: group.expected_answer,
                                candidate: candidate.candidate_word,
                                similarity: candidate.similarity,
                                expectedMag: expectedMag.toFixed(6),
                                candidateMag: candidateMag.toFixed(6)
                            });
                        }
                    }

                    // ìœ ì‚¬ë„ì™€ ë¹ˆë„ìˆ˜ë¡œ ì •ë ¬
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // ê²°ê³¼ êµ¬ì¡° ìƒì„± (ë¬¸ì¥/ë‹¨ì–´ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¦„)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('ê²°ê³¼ ë°ì´í„°:', JSON.stringify(analysisResults));
                // 4. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ê²°ê³¼ í‘œì‹œ
                if (dataType === 'word') {
                    displayWordResults();
                } else if (dataType === 'sentence') {
                    displaySentenceResults();
                }

            } catch (error) {
                console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
                document.getElementById('loading').innerHTML = `<div class="error">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}</div>`;
            }
        }

        // ë‹¨ì–´ìš© ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displayWordResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // ìœ ì‚¬ë„ ìƒì„¸ ì •ë³´ ìƒì„±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    ì£¼ìš” ìœ ì‚¬ë„: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ìƒì„¸ë³´ê¸°</button>
                                    <br>
                                    ì¶œí˜„íšŸìˆ˜: ${candidate.frequency}íšŒ |
                                    ì›ë³¸íŒì •: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>ëª¨ë“  ìœ ì‚¬ë„ ê³„ì‚° ê²°ê³¼:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>ë¶„ì„:</strong><br>
                                    â€¢ ìµœê³ ì : ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    â€¢ ìµœì €ì : ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    â€¢ í‰ê· : ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    â€¢ ë¶„ì‚°: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ìŠ¹ì¸</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">ê±°ì ˆ</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id}</h3>
                        <div class="expected">ì •ë‹µ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // ë¬¸ì¥ìš© ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displaySentenceResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const keywordClass = candidate.keyword_included ? 'similarity-high' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // ìœ ì‚¬ë„ ìƒì„¸ ì •ë³´ ìƒì„±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word" style="font-size: 0.95rem; line-height: 1.4;">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    í‚¤ì›Œë“œ: <strong>${candidate.keyword}</strong> |
                                    í‚¤ì›Œë“œ í¬í•¨: <span class="${keywordClass}">${candidate.keyword_included ? 'YES' : 'NO'}</span>
                                    <br>
                                    ì£¼ìš” ìœ ì‚¬ë„: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ìƒì„¸ë³´ê¸°</button>
                                    <br>
                                    ì¶œí˜„íšŸìˆ˜: ${candidate.frequency}íšŒ |
                                    ì›ë³¸íŒì •: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>ëª¨ë“  ìœ ì‚¬ë„ ê³„ì‚° ê²°ê³¼:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>ë¶„ì„:</strong><br>
                                    â€¢ ìµœê³ ì : ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    â€¢ ìµœì €ì : ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    â€¢ í‰ê· : ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    â€¢ ë¶„ì‚°: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ìŠ¹ì¸</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">ê±°ì ˆ</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id} | í‚¤ì›Œë“œ: "${result.keyword || result.expected_answer}"</h3>
                        <div class="expected" style="font-size: 0.95rem; line-height: 1.4; margin-top: 10px;">ì •ë‹µ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // ìŠ¹ì¸ ì²˜ë¦¬
        function approveCandidate(candidateId) {
            approvalStatus[candidateId] = 'approved';
            const element = document.getElementById(`candidate_${candidateId}`);
            element.className = 'candidate-item approved';
            console.log(`ìŠ¹ì¸ë¨: ${candidateId}`);

            // ìŠ¹ì¸/ê±°ì ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ìµœì¢… ê²°ê³¼ ì¶œë ¥
            updateFinalResults();
        }

        // ê±°ì ˆ ì²˜ë¦¬
        function rejectCandidate(candidateId) {
            approvalStatus[candidateId] = 'rejected';
            const element = document.getElementById(`candidate_${candidateId}`);
            element.className = 'candidate-item rejected';
            console.log(`ê±°ì ˆë¨: ${candidateId}`);

            // ìŠ¹ì¸/ê±°ì ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ìµœì¢… ê²°ê³¼ ì¶œë ¥
            updateFinalResults();
        }

        // ìµœì¢… ê²°ê³¼ ì—…ë°ì´íŠ¸ (ìš”ì²­í•˜ì‹  JSON í˜•íƒœë¡œ)
        function updateFinalResults() {
            const finalResults = analysisResults.map(result => {
                const approvedCandidates = result.candidates.filter(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    return approvalStatus[candidateId] === 'approved';
                });

                return {
                    id: result.id,
                    expected_answer: result.expected_answer,
                    candidates: result.candidates.map(candidate => ({
                        log_id: candidate.log_id,
                        candidate_word: candidate.candidate_word,
                        similarity: candidate.similarity,
                        similarities: candidate.similarities, // ëª¨ë“  ìœ ì‚¬ë„ ì ìˆ˜ í¬í•¨
                        origin_judge: candidate.origin_judge,
                        frequency: candidate.frequency,
                        approval_status: approvalStatus[`${result.id}_${candidate.candidate_word}`] || 'pending'
                    }))
                };
            });

            console.log('ìµœì¢… ê²°ê³¼ (ìš”ì²­ í˜•íƒœ):', JSON.stringify(finalResults, null, 2));
        }

        // ëª¨ë“  ê²°ê³¼ ìŠ¹ì¸
        function approveAll() {
            analysisResults.forEach(result => {
                result.candidates.forEach(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    approveCandidate(candidateId);
                });
            });
        }

        // ëª¨ë“  ê²°ê³¼ ê±°ì ˆ
        function rejectAll() {
            analysisResults.forEach(result => {
                result.candidates.forEach(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    rejectCandidate(candidateId);
                });
            });
        }

        // ê²°ê³¼ ë‚´ë³´ë‚´ê¸° (JSON íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ)
        function exportResults() {
            const finalResults = analysisResults.map(result => {
                return {
                    id: result.id,
                    expected_answer: result.expected_answer,
                    candidates: result.candidates.map(candidate => ({
                        log_id: candidate.log_id,
                        candidate_word: candidate.candidate_word,
                        similarity: candidate.similarity,
                        similarities: candidate.similarities, // ëª¨ë“  ìœ ì‚¬ë„ ì ìˆ˜ í¬í•¨
                        origin_judge: candidate.origin_judge,
                        frequency: candidate.frequency,
                        approval_status: approvalStatus[`${result.id}_${candidate.candidate_word}`] || 'pending'
                    }))
                };
            });

            // JSON íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ
            const dataStr = JSON.stringify(finalResults, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `similarity_analysis_results_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('ê²°ê³¼ê°€ JSON íŒŒì¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤.');
        }

        // ìœ ì‚¬ë„ ìƒì„¸ì •ë³´ í† ê¸€ í•¨ìˆ˜
        function toggleSimilarityDetails(candidateId) {
            const detailsElement = document.getElementById(`similarity_${candidateId}`);
            const toggleButton = event.target;

            if (detailsElement.style.display === 'none') {
                detailsElement.style.display = 'block';
                toggleButton.textContent = 'ìˆ¨ê¸°ê¸°';
            } else {
                detailsElement.style.display = 'none';
                toggleButton.textContent = 'ìƒì„¸ë³´ê¸°';
            }
        }
    </script>
</body>
</html>
