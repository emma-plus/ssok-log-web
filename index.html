<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Î∂ÑÏÑù ÌååÏù¥ÌîÑÎùºÏù∏ - Ïú†ÏÇ¨Ïñ¥ Î∂ÑÏÑù</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #404040;
        }

        .header h1 {
            color: #4fc3f7;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .header p {
            color: #b0b0b0;
            font-size: 1.1rem;
        }

        .input-section {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 30px;
            border: 1px solid #404040;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e0e0e0;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #555;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #4fc3f7;
        }

        .input-group textarea {
            height: 120px;
            resize: vertical;
            font-family: monospace;
        }

        .btn {
            background: #4fc3f7;
            color: #1a1a1a;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #29b6f6;
        }

        .btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #b0b0b0;
        }

        .results-section {
            display: none;
        }

        .result-item {
            background: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid #404040;
        }

        .result-header {
            background: #3a3a3a;
            color: #e0e0e0;
            padding: 20px;
        }

        .result-header h3 {
            margin-bottom: 5px;
        }

        .result-header .expected {
            font-size: 1.2rem;
            font-weight: 600;
            color: #b0b0b0;
        }

        .candidates-list {
            padding: 20px;
        }

        .candidate-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 2px solid #555;
            border-radius: 8px;
            margin-bottom: 10px;
            transition: all 0.3s;
            background: #3a3a3a;
        }

        .candidate-item:hover {
            border-color: #4fc3f7;
            background: #404040;
        }

        .candidate-info {
            flex: 1;
        }

        .candidate-word {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 5px;
        }

        .candidate-stats {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .candidate-actions {
            display: flex;
            gap: 10px;
        }

        .btn-approve {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-approve:hover {
            background: #219a52;
        }

        .btn-reject {
            background: #e74c3c;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn-reject:hover {
            background: #c0392b;
        }

        .approved {
            border-color: #4caf50 !important;
            background: #2d4a2d !important;
        }

        .rejected {
            border-color: #f44336 !important;
            background: #4a2d2d !important;
        }

        .similarity-high {
            color: #4caf50;
            font-weight: 600;
        }

        .similarity-medium {
            color: #ff9800;
            font-weight: 600;
        }

        .similarity-low {
            color: #f44336;
            font-weight: 600;
        }

        .similarity-details {
            margin-top: 10px;
            padding: 10px;
            background: #404040;
            border-radius: 5px;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .similarity-method {
            display: inline-block;
            margin: 2px;
            padding: 3px 8px;
            border-radius: 3px;
            background: #555;
            color: #e0e0e0;
        }

        .similarity-method.best {
            background: #4caf50;
            color: white;
        }

        .similarity-method.worst {
            background: #f44336;
            color: white;
        }

        .similarity-toggle {
            background: #666;
            color: #e0e0e0;
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .similarity-toggle:hover {
            background: #777;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ AI Î∂ÑÏÑù ÌååÏù¥ÌîÑÎùºÏù∏</h1>
            <p>Ïú†ÏÇ¨Ïñ¥ ÌõÑÎ≥¥ Î∂ÑÏÑù Î∞è ÏäπÏù∏/Í±∞Ï†à Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API ÌÇ§</label>
                <!-- todo test ÏûÑ :: key ÏÇ≠Ï†ú ÌïÑÏöî -->
                <input type="password" id="apiKey" placeholder="sk-...">
            </div>

            <div class="input-group">
                <label>Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        Îã®Ïñ¥
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        Î¨∏Ïû•
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API ÏÇ¨Ïö©</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        ÏÇ¨Ïö©
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        ÏÇ¨Ïö© ÏïàÌï® (Ï†ÑÏ≤òÎ¶¨Îßå)
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>Ï†ÑÏ≤òÎ¶¨ ÏòµÏÖò</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="enablePreprocessing" checked style="margin-right: 8px;">
                        Ï†ÑÏ≤òÎ¶¨ ÌôúÏÑ±Ìôî
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="basicNormalization" checked style="margin-right: 8px;">
                        Í∏∞Î≥∏ Ï†ïÍ∑úÌôî
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="koreanProcessing" checked style="margin-right: 8px;">
                        ÌïúÍµ≠Ïñ¥ Ï≤òÎ¶¨
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="domainSpecific" checked style="margin-right: 8px;">
                        ÎèÑÎ©îÏù∏ ÌäπÌôî Ï≤òÎ¶¨
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label for="domainSelect" style="display: block; margin-bottom: 5px; font-weight: normal;">ÎèÑÎ©îÏù∏ ÏÑ†ÌÉù:</label>
                    <select id="domainSelect" style="width: 200px; padding: 5px; background: #3a3a3a; color: #e0e0e0; border: 2px solid #555; border-radius: 4px;">
                        <option value="auto">ÏûêÎèô Í∞êÏßÄ</option>
                        <option value="learning" selected>ÌïôÏäµ (Ïà´Ïûê/Îã®ÏúÑ)</option>
                        <option value="general">ÏùºÎ∞ò</option>
                        <option value="tech">Í∏∞Ïà†</option>
                        <option value="brand">Î∏åÎûúÎìú</option>
                    </select>
                </div>
            </div>

            <div class="input-group">
                <label for="csvData">Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ (CSV/TSV ÌòïÏãù)</label>
                <textarea id="csvData" placeholder="Îã®Ïñ¥ ÌòïÌÉú - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,Ïä§ÎÉÖÎìúÎûòÍ≥§ 8,,Ïä§ÎÉÖÎìúÎûò Í≥∞ÌååÏóê&#10;Îã®Ïñ¥ ÌòïÌÉú - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		Ìè¨ÌÜ†		ÏïàÌã∞&#10;&#10;Î¨∏Ïû• ÌòïÌÉú - TSV: 521	3985	18.5	FALSE	ÏÑ§Î™Ö	SENTENCE_SIMILARITY_PASS_FAIL_V2	ÏïàÌã∞Îî•Î≥¥Ïù¥Ïä§		ÏõêÎ≥∏Î¨∏Ïû•		ÏÇ¨Ïö©ÏûêÎãµÎ≥ÄÎ¨∏Ïû•"></textarea>
            </div>

            <button class="btn" onclick="analyzeData()">Î∂ÑÏÑù ÏãúÏûë</button>
        </div>

        <div class="loading" id="loading">
            <p>üîÑ AIÍ∞Ä Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑù Ï§ëÏûÖÎãàÎã§...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">Î™®Îëê ÏäπÏù∏</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">Î™®Îëê Í±∞Ï†à</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6;">Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- similarity.js Î™®Îìà Î°úÎìú -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js Î™®Îìà Î°úÎìú -->
    <script src="./preprocessing.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};

        // CSV/TSV Îã®Ïñ¥ Îç∞Ïù¥ÌÑ∞Î•º ÌååÏã±ÌïòÎäî Ìï®Ïàò
        function parseWordData(dataText) {
            const lines = dataText.trim().split('\n');
            const data = [];

            // Ïπ¥Ïö¥ÌÑ∞ Î≥ÄÏàòÎì§
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // Îç∞Ïù¥ÌÑ∞ ÌòïÌÉú ÏûêÎèô Í∞êÏßÄ (Ï≤´ Î≤àÏß∏ Ïú†Ìö®Ìïú ÎùºÏù∏ÏúºÎ°ú ÌåêÎã®)
            let delimiter = ','; // Í∏∞Î≥∏Í∞íÏùÄ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // ÌÉ≠Í≥º ÏâºÌëú Í∞úÏàòÎ•º ÏÑ∏Ïñ¥ÏÑú Îçî ÎßéÏùÄ Ï™ΩÏúºÎ°ú Í≤∞Ï†ï
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV ÌòïÌÉúÎ°ú Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.');
                    } else {
                        delimiter = ',';
                        console.log('CSV ÌòïÌÉúÎ°ú Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // Îπà Ï§Ñ Ï≤¥ÌÅ¨
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // Ï£ºÏÑù ÎùºÏù∏ Ï≤¥ÌÅ¨
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`Ï£ºÏÑù ÎùºÏù∏ Í±¥ÎÑàÎõ∞Í∏∞: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        answer: parts[7].trim(),
                        user_answer: parts[9].trim()
                    });
                } else {
                    skippedInvalidLines++;
                    console.log(`Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎùºÏù∏ (Ïª¨Îüº Ïàò Î∂ÄÏ°±): ${trimmedLine}`);
                }
            }

            console.log('=== ÌååÏã± Í≤∞Í≥º ÏöîÏïΩ ===');
            console.log(`Ï†ÑÏ≤¥ ÎùºÏù∏ Ïàò: ${totalLines}`);
            console.log(`ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌååÏã±Îêú Î†àÏΩîÎìú: ${data.length}`);
            console.log(`Í±¥ÎÑàÎõ¥ Îπà Ï§Ñ: ${skippedEmptyLines}`);
            console.log(`Í±¥ÎÑàÎõ¥ Ï£ºÏÑù ÎùºÏù∏: ${skippedCommentLines}`);
            console.log(`Í±¥ÎÑàÎõ¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎùºÏù∏: ${skippedInvalidLines}`);
            console.log(`ÏÇ¨Ïö©Îêú Íµ¨Î∂ÑÏûê: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // CSV/TSV Î¨∏Ïû• Îç∞Ïù¥ÌÑ∞Î•º ÌååÏã±ÌïòÎäî Ìï®Ïàò
        function parseSentenceData(dataText) {
            const lines = dataText.trim().split('\n');
            const data = [];

            // Ïπ¥Ïö¥ÌÑ∞ Î≥ÄÏàòÎì§
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // Îç∞Ïù¥ÌÑ∞ ÌòïÌÉú ÏûêÎèô Í∞êÏßÄ (Ï≤´ Î≤àÏß∏ Ïú†Ìö®Ìïú ÎùºÏù∏ÏúºÎ°ú ÌåêÎã®)
            let delimiter = ','; // Í∏∞Î≥∏Í∞íÏùÄ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // ÌÉ≠Í≥º ÏâºÌëú Í∞úÏàòÎ•º ÏÑ∏Ïñ¥ÏÑú Îçî ÎßéÏùÄ Ï™ΩÏúºÎ°ú Í≤∞Ï†ï
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV ÌòïÌÉúÎ°ú Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.');
                    } else {
                        delimiter = ',';
                        console.log('CSV ÌòïÌÉúÎ°ú Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // Îπà Ï§Ñ Ï≤¥ÌÅ¨
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // Ï£ºÏÑù ÎùºÏù∏ Ï≤¥ÌÅ¨
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`Ï£ºÏÑù ÎùºÏù∏ Í±¥ÎÑàÎõ∞Í∏∞: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                // Î¨∏Ïû• Îç∞Ïù¥ÌÑ∞Îäî ÏµúÏÜå 10Í∞ú Ïª¨ÎüºÏù¥ ÌïÑÏöî (id, user_id, version, judge, description, type, keyword, empty, original_sentence, user_sentence)
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        version: parts[2].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        description: parts[4].trim(),
                        type: parts[5].trim(),
                        keyword: parts[6].trim(),
                        empty1: parts[7].trim(),
                        answer: parts[8].trim(), // ÏõêÎ≥∏ Î¨∏Ïû•
                        user_answer: parts[9].trim() // ÏÇ¨Ïö©Ïûê ÎãµÎ≥Ä Î¨∏Ïû•
                    });
                } else {
                    skippedInvalidLines++;
                    console.log(`Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎùºÏù∏ (Ïª¨Îüº Ïàò Î∂ÄÏ°±): ${trimmedLine}`);
                }
            }

            console.log('=== Î¨∏Ïû• Îç∞Ïù¥ÌÑ∞ ÌååÏã± Í≤∞Í≥º ÏöîÏïΩ ===');
            console.log(`Ï†ÑÏ≤¥ ÎùºÏù∏ Ïàò: ${totalLines}`);
            console.log(`ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌååÏã±Îêú Î†àÏΩîÎìú: ${data.length}`);
            console.log(`Í±¥ÎÑàÎõ¥ Îπà Ï§Ñ: ${skippedEmptyLines}`);
            console.log(`Í±¥ÎÑàÎõ¥ Ï£ºÏÑù ÎùºÏù∏: ${skippedCommentLines}`);
            console.log(`Í±¥ÎÑàÎõ¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎùºÏù∏: ${skippedInvalidLines}`);
            console.log(`ÏÇ¨Ïö©Îêú Íµ¨Î∂ÑÏûê: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // Îã®Ïñ¥ Îç∞Ïù¥ÌÑ∞Î•º Í∑∏Î£πÌïëÌïòÎäî Ìï®Ïàò (expected_answerÎ≥ÑÎ°ú Í∑∏Î£πÌïë)
        function groupWordData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer) continue;

                const key = row.answer;
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        candidates: []
                    };
                }

                // Ï§ëÎ≥µ Ï†úÍ±∞Î•º ÏúÑÌï¥ Í∏∞Ï°¥ ÌõÑÎ≥¥ Ï§ëÏóêÏÑú Í∞ôÏùÄ user_answerÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        similarity: 0, // ÏûÑÎ≤†Îî© Í≥ÑÏÇ∞ ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // Î¨∏Ïû• Îç∞Ïù¥ÌÑ∞Î•º Í∑∏Î£πÌïëÌïòÎäî Ìï®Ïàò (ÌÇ§ÏõåÎìúÎ≥ÑÎ°ú Í∑∏Î£πÌïë)
        function groupSentenceData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer || !row.keyword) continue;

                const key = row.keyword; // ÌÇ§ÏõåÎìúÎ°ú Í∑∏Î£πÌïë
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        keyword: row.keyword,
                        candidates: []
                    };
                }

                // Ï§ëÎ≥µ Ï†úÍ±∞Î•º ÏúÑÌï¥ Í∏∞Ï°¥ ÌõÑÎ≥¥ Ï§ëÏóêÏÑú Í∞ôÏùÄ user_answerÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        keyword: row.keyword,
                        keyword_included: false, // ÌÇ§ÏõåÎìú Ìè¨Ìï® Ïó¨Î∂Ä (ÎÇòÏ§ëÏóê Í≥ÑÏÇ∞)
                        similarity: 0, // ÏûÑÎ≤†Îî© Í≥ÑÏÇ∞ ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // ÌÇ§ÏõåÎìú Ïú†ÏÇ¨ÎèÑ Í≤ÄÏ¶ù Ìï®Ïàò (ÌÇ§ÏõåÎìúÍ∞Ä Î¨∏Ïû•Ïóê Ìè¨Ìï®ÎêòÏñ¥ ÏûàÎäîÏßÄ Ïú†ÏÇ¨ÎèÑÎ°ú ÌôïÏù∏)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // ÌÇ§ÏõåÎìúÏôÄ Î¨∏Ïû•ÏóêÏÑú ÌÇ§ÏõåÎìú Î∂ÄÎ∂ÑÏùÑ Ï∂îÏ∂úÌïòÏó¨ ÎπÑÍµê
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // Î¨∏Ïû•ÏùÑ Îã®Ïñ¥Î°ú Î∂ÑÎ¶¨ÌïòÏó¨ Í∞Å Îã®Ïñ¥ÏôÄ ÌÇ§ÏõåÎìúÏùò Ïú†ÏÇ¨ÎèÑ ÌôïÏù∏
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('ÌÇ§ÏõåÎìú Ïú†ÏÇ¨ÎèÑ Í≤ÄÏ¶ù Ïò§Î•ò:', error);
                // Ïò§Î•ò Ïãú Î¨∏ÏûêÏó¥ Ìè¨Ìï® Ïó¨Î∂ÄÎ°ú ÎåÄÏ≤¥
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI ÏûÑÎ≤†Îî© API Ìò∏Ï∂ú (Îã®Ïùº ÌÖçÏä§Ìä∏)
        async function getEmbedding(text, apiKey) {
            // todo ÏùºÎã® Ï£ºÏÑù
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // Îçî ÎÜíÏùÄ Ï∞®ÏõêÏúºÎ°ú Îçî Ï†ïÌôïÌïú ÏûÑÎ≤†Îî©
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API Ïò§Î•ò: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // ÌÖçÏä§Ìä∏ Î∞∞Ïó¥ Í≤ÄÏ¶ù Î∞è Ï†ïÎ¶¨ Ìï®Ïàò
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏ Î∞∞Ïó¥Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
            }

            const validTexts = texts.filter(text => text && typeof text === 'string' && text.trim().length > 0);

            if (validTexts.length === 0) {
                throw new Error('Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.');
            }

            if (validTexts.length !== texts.length) {
                console.warn(`${texts.length - validTexts.length}Í∞úÏùò Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÖçÏä§Ìä∏Í∞Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.`);
            }

            return validTexts;
        }

        // ÎîîÎ≤ÑÍπÖÏö© ÌÖçÏä§Ìä∏ Î∞∞Ïó¥ Î∂ÑÏÑù Ìï®Ïàò
        function logTextAnalysis(validTexts) {
            console.log('=== ÌÖçÏä§Ìä∏ Î∞∞Ïó¥ Î∂ÑÏÑù ===');
            console.log('Î∞∞Ïó¥ ÌÉÄÏûÖ:', Array.isArray(validTexts));
            console.log('Î∞∞Ïó¥ Í∏∏Ïù¥:', validTexts.length);

            // Í∞Å ÌÖçÏä§Ìä∏Ïùò ÌÉÄÏûÖÍ≥º Í∏∏Ïù¥ ÌôïÏù∏
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('Ï≤òÏùå 10Í∞ú ÌÖçÏä§Ìä∏ Î∂ÑÏÑù:', textAnalysis);

            // Îπà Î¨∏ÏûêÏó¥Ïù¥ÎÇò Î¨∏Ï†úÍ∞Ä Îê† Ïàò ÏûàÎäî ÌÖçÏä§Ìä∏ Ï∞æÍ∏∞
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('Î¨∏Ï†úÍ∞Ä Îê† Ïàò ÏûàÎäî ÌÖçÏä§Ìä∏Îì§:', problematicTexts);
            }
            console.log('========================');
        }

        // API ÏöîÏ≤≠ ÌéòÏù¥Î°úÎìú Î°úÍπÖ Ìï®Ïàò
        function logRequestPayload(requestPayload) {
            console.log('API ÏöîÏ≤≠ ÌéòÏù¥Î°úÎìú ÎØ∏Î¶¨Î≥¥Í∏∞:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API Ïò§Î•ò Î°úÍπÖ Ìï®Ïàò
        async function logApiError(response, requestPayload) {
            console.error('API ÏöîÏ≤≠ Ïã§Ìå®!');
            console.error('ÏùëÎãµ ÏÉÅÌÉú:', response.status);
            console.error('ÏùëÎãµ Ìó§Îçî:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('ÏùëÎãµ Î≥∏Î¨∏ (ÌÖçÏä§Ìä∏):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('ÌååÏã±Îêú Ïò§Î•ò Îç∞Ïù¥ÌÑ∞:', errorData);
            } catch (parseError) {
                console.error('ÏùëÎãµÏùÑ JSONÏúºÎ°ú ÌååÏã±Ìï† Ïàò ÏóÜÏùå:', parseError);
                errorData = { message: errorText };
            }

            // ÏöîÏ≤≠ÌñàÎçò Îç∞Ïù¥ÌÑ∞ÎèÑ Ìï®Íªò Î°úÍπÖ
            console.error('Ïã§Ìå®Ìïú ÏöîÏ≤≠Ïùò input ÏÉòÌîå (Ï≤òÏùå 3Í∞ú):', requestPayload.input.slice(0, 3));
            console.error('Ïã§Ìå®Ìïú ÏöîÏ≤≠Ïùò Ï†ÑÏ≤¥ ÌéòÏù¥Î°úÎìú:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI ÏûÑÎ≤†Îî© API Î∞∞Ïπò Ìò∏Ï∂ú (Ïó¨Îü¨ ÌÖçÏä§Ìä∏ Ìïú Î≤àÏóê)
        async function getBatchEmbeddings(texts, apiKey) {


            // // // todo temp - embedding // word_under70_yellow_false.csv
            // // // console.log('embedding_response_word_under70_yellow_false.txt ÌååÏùºÏóêÏÑú ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌï©ÎãàÎã§...');
            // // // // embedding_response.txt ÌååÏùºÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            // // // const response = await fetch('./embedding_response_word_under70_yellow_false.txt');
            // //
            // // // console.log('embedding_response_word_under70_yellow_true.txt ÌååÏùºÏóêÏÑú ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌï©ÎãàÎã§...');
            // // // const response = await fetch('./embedding_response_word_under70_yellow_true.txt');
            // //
            // console.log('embding_8inch.txt ÌååÏùºÏóêÏÑú ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌï©ÎãàÎã§...');
            // const response = await fetch('./embding_8inch.txt');


            // todo openai - embedding /
            // todo Ï†ÑÏ≤òÎ¶¨Î•º Ï∂îÍ∞ÄÌñàÏúºÎãà, Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º ÎÑ£Í≥†, Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞Î•º ÎΩëÏïÑÎ≥¥Ïûê!!

            // 1. ÌÖçÏä§Ìä∏ Í≤ÄÏ¶ù Î∞è Ï†ïÎ¶¨
            const validTexts = validateAndCleanTexts(texts);

            // 2. ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏
            console.log('APIÎ•º ÌÜµÌï¥ ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌï©ÎãàÎã§...');
            console.log(`Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏ ${validTexts.length}Í∞ú:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            // 3. API ÏöîÏ≤≠ Ï§ÄÎπÑ
            const requestPayload = {
                model: 'text-embedding-3-small',
                input: validTexts,
                dimensions: 1024
            };

            logRequestPayload(requestPayload);

            // 4. API Ìò∏Ï∂ú
            const response = await fetch('https://api.openai.com/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify(requestPayload)
            });

            console.log('API ÏùëÎãµ ÏÉÅÌÉú:', response.status, response.statusText);

            // 5. Ïò§Î•ò Ï≤òÎ¶¨
            if (!response.ok) {
                const errorData = await logApiError(response, requestPayload);
                throw new Error(`OpenAI API Ïò§Î•ò: ${response.status} - ${JSON.stringify(errorData)}`);
            }
            /////////

            // 6. ÏÑ±Í≥µ ÏùëÎãµ Ï≤òÎ¶¨
            const data = await response.json();
            console.log(`${data.data.length}Í∞úÏùò ÏûÑÎ≤†Îî©ÏùÑ Î°úÎìúÌñàÏäµÎãàÎã§.`);
            return data.data.map(item => item.embedding);
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎì§ÏùÄ similarity.jsÎ°ú Ïù¥ÎèôÎê®

        // Î©îÏù∏ Î∂ÑÏÑù Ìï®Ïàò
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';

            if (useOpenAI && !apiKey) {
                alert('OpenAI APIÎ•º ÏÇ¨Ïö©ÌïòÎ†§Î©¥ API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            if (!csvData) {
                alert('Î∂ÑÏÑùÌï† Îç∞Ïù¥ÌÑ∞Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. ÏÑ†ÌÉùÎêú ÌÉÄÏûÖÏóê Îî∞Îùº Îç∞Ïù¥ÌÑ∞ ÌååÏã±
                let parsedData;
                if (dataType === 'word') {
                    console.log('Îã®Ïñ¥ Îç∞Ïù¥ÌÑ∞ ÌååÏã± ÏãúÏûë...');
                    parsedData = parseWordData(csvData);
                } else if (dataType === 'sentence') {
                    console.log('Î¨∏Ïû• Îç∞Ïù¥ÌÑ∞ ÌååÏã± ÏãúÏûë...');
                    parsedData = parseSentenceData(csvData);
                }
                console.log('ÌååÏã±Îêú Îç∞Ïù¥ÌÑ∞:', JSON.stringify(parsedData));

                // 2. ÏÑ†ÌÉùÎêú ÌÉÄÏûÖÏóê Îî∞Îùº Îç∞Ïù¥ÌÑ∞ Í∑∏Î£πÌïë
                let groupedData;
                if (dataType === 'word') {
                    groupedData = groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = groupSentenceData(parsedData);
                }
                console.log('Í∑∏Î£πÌïëÎêú Îç∞Ïù¥ÌÑ∞:', JSON.stringify(groupedData));

                // 3. Î∞∞ÏπòÎ°ú ÏûÑÎ≤†Îî© Í≥ÑÏÇ∞ Î∞è Ïú†ÏÇ¨ÎèÑ Î∂ÑÏÑù
                analysisResults = [];
                let idCounter = 1;

                // Î™®Îì† ÌÖçÏä§Ìä∏Î•º Ìïú Î≤àÏóê ÏàòÏßë
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // ÌÖçÏä§Ìä∏ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù Ìï®Ïàò
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UIÏóêÏÑú Ï†ÑÏ≤òÎ¶¨ ÏòµÏÖò Í∞ÄÏ†∏Ïò§Í∏∞
                const enablePreprocessing = document.getElementById('enablePreprocessing').checked;
                const preprocessingOptions = {
                    numericNormalization: true, // STT Ïà´Ïûê ÌëúÌòÑ Ï†ïÍ∑úÌôî Ìï≠ÏÉÅ ÌôúÏÑ±Ìôî
                    normalize: document.getElementById('basicNormalization').checked,
                    korean: document.getElementById('koreanProcessing').checked,
                    clean: document.getElementById('basicNormalization').checked, // Í∏∞Î≥∏ Ï†ïÍ∑úÌôîÏóê Ìè¨Ìï®
                    domainProcessing: document.getElementById('domainSpecific').checked,
                    domain: document.getElementById('domainSelect').value === 'auto' ? null : document.getElementById('domainSelect').value,
                    debug: true // ÎîîÎ≤ÑÍπÖ ÌôúÏÑ±ÌôîÎ°ú Ï†ÑÏ≤òÎ¶¨ Í≥ºÏ†ï ÌôïÏù∏
                };

                console.log('Ï†ÑÏ≤òÎ¶¨ ÏÑ§Ï†ï:', { enablePreprocessing, ...preprocessingOptions });

                // todo --- Ïó¨Í∏∞ Ïù¥Ïñ¥ÏÑú ÏßÑÌñâ


                //// Ï†ÑÏ≤òÎ¶¨ ÏãúÏûë
                // Ï†ïÎãµÎì§ Î®ºÏ†Ä ÏàòÏßë (Ï†ÑÏ≤òÎ¶¨ Ï†ÅÏö©)
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        const preprocessedAnswer = enablePreprocessing ?
                            TextPreprocessor.preprocessText(answer.trim(), preprocessingOptions) :
                            answer.trim();

                        // Ï†ÑÏ≤òÎ¶¨ ÌõÑÏóêÎèÑ Ïú†Ìö®ÌïúÏßÄ Ïû¨ÌôïÏù∏
                        if (isValidText(preprocessedAnswer)) {
                            allTexts.push(preprocessedAnswer);
                            textIndexMap.set(`expected_${answer}`, textIndex++);
                        } else {
                            console.warn(`Ï†ÑÏ≤òÎ¶¨ ÌõÑ Îπà ÌÖçÏä§Ìä∏Í∞Ä Îê®:`, answer, '‚Üí', preprocessedAnswer);
                            // Ï†ÑÏ≤òÎ¶¨ ÏóÜÏù¥ ÏõêÎ≥∏ ÏÇ¨Ïö©
                            allTexts.push(answer.trim());
                            textIndexMap.set(`expected_${answer}`, textIndex++);
                        }
                    } else {
                        console.warn(`Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï†ïÎãµ ÌÖçÏä§Ìä∏:`, answer);
                    }
                });

                console.log('Ï†ïÎãµÎì§ > Ï†ÑÏ≤òÎ¶¨ Ï†ÅÏö©:', { ...allTexts });

                // Î™®Îì† ÌõÑÎ≥¥ Îã®Ïñ¥Îì§ ÏàòÏßë (Ï†ÑÏ≤òÎ¶¨ Ï†ÅÏö©)
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            const preprocessedCandidate = enablePreprocessing ?
                                TextPreprocessor.preprocessText(candidate.candidate_word.trim(), preprocessingOptions) :
                                candidate.candidate_word.trim();

                            // Ï†ÑÏ≤òÎ¶¨ ÌõÑÏóêÎèÑ Ïú†Ìö®ÌïúÏßÄ Ïû¨ÌôïÏù∏
                            if (isValidText(preprocessedCandidate)) {
                                allTexts.push(preprocessedCandidate);
                                textIndexMap.set(`candidate_${group.expected_answer}_${candidate.candidate_word}`, textIndex++);
                            } else {
                                console.warn(`Ï†ÑÏ≤òÎ¶¨ ÌõÑ Îπà ÌÖçÏä§Ìä∏Í∞Ä Îê®:`, candidate.candidate_word, '‚Üí', preprocessedCandidate);
                                // Ï†ÑÏ≤òÎ¶¨ ÏóÜÏù¥ ÏõêÎ≥∏ ÏÇ¨Ïö©
                                allTexts.push(candidate.candidate_word.trim());
                                textIndexMap.set(`candidate_${group.expected_answer}_${candidate.candidate_word}`, textIndex++);
                            }
                        } else {
                            console.warn(`Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌõÑÎ≥¥ ÌÖçÏä§Ìä∏:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('Î™®Îì† ÌõÑÎ≥¥ Îã®Ïñ¥Îì§ > Ï†ÑÏ≤òÎ¶¨ Ï†ÅÏö©:', { ...allTexts });

                console.log(`Ï¥ù ${allTexts.length}Í∞ú Ïú†Ìö®Ìïú ÌÖçÏä§Ìä∏Î•º Î∞∞ÏπòÎ°ú ÏûÑÎ≤†Îî© Ï≤òÎ¶¨Ìï©ÎãàÎã§.`);

                // Îπà ÌÖçÏä§Ìä∏Í∞Ä ÏûàÎäîÏßÄ ÏµúÏ¢Ö ÌôïÏù∏
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`Îπà ÌÖçÏä§Ìä∏ ${emptyTexts.length}Í∞ú Î∞úÍ≤¨:`, emptyTexts);
                    throw new Error(`Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÖçÏä§Ìä∏Í∞Ä ${emptyTexts.length}Í∞ú Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.`);
                }

                //// Ï†ÑÏ≤òÎ¶¨ ÎÅù

                // OpenAI API ÏÇ¨Ïö© Ïó¨Î∂ÄÏóê Îî∞Îùº Î∂ÑÍ∏∞ Ï≤òÎ¶¨
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI APIÎ•º ÌÜµÌïú ÏûÑÎ≤†Îî© Í≥ÑÏÇ∞
                    console.log('OpenAI APIÎ•º ÌÜµÌï¥ ÏûÑÎ≤†Îî©ÏùÑ Í≥ÑÏÇ∞Ìï©ÎãàÎã§...');
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey);
                } else {
                    // OpenAI API ÏóÜÏù¥ Ï†ÑÏ≤òÎ¶¨Îßå ÏàòÌñâ - ÎçîÎØ∏ ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                    console.log('Ï†ÑÏ≤òÎ¶¨Îßå ÏàòÌñâÌï©ÎãàÎã§. OpenAI APIÎäî ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                    console.log('Ï†ÑÏ≤òÎ¶¨Îêú ÌÖçÏä§Ìä∏Îì§:', allTexts);

                    // ÎçîÎØ∏ ÏûÑÎ≤†Îî© Îç∞Ïù¥ÌÑ∞ (Î™®Îì† Í∞íÏù¥ 0.5Ïù∏ 1024Ï∞®Ïõê Î≤°ÌÑ∞)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // Í∞Å Í∑∏Î£πÏóê ÎåÄÌï¥ Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                for (const group of groupedData) {
                    const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}`)];

                    // Í∞Å ÌõÑÎ≥¥Ïóê ÎåÄÌï¥ Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
                    for (const candidate of group.candidates) {
                        const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}`)];

                        // Îã§ÏñëÌïú Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Î∞©Î≤ï ÏÇ¨Ïö©
                        const similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);

                        // Í∞Å Ïú†ÏÇ¨ÎèÑ Í≤∞Í≥ºÎ•º Ï†ÄÏû•
                        candidate.similarities = similarities;

                        // Í∏∞Î≥∏ Ïú†ÏÇ¨ÎèÑÎäî ÏΩîÏÇ¨Ïù∏ Ïú†ÏÇ¨ÎèÑ ÏÇ¨Ïö© (Í∏∞Ï°¥ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
                        candidate.similarity = similarities.cosine;

                        // todo test - checkKeywordSimilarity ÏùºÎã® Ìå®Ïä§
                        // // Î¨∏Ïû• ÌÉÄÏûÖÏù∏ Í≤ΩÏö∞ ÌÇ§ÏõåÎìú Ìè¨Ìï® Ïó¨Î∂Ä ÌôïÏù∏
                        // if (dataType === 'sentence' && candidate.keyword) {
                        //     candidate.keyword_included = await checkKeywordSimilarity(candidate.keyword, candidate.candidate_word, apiKey);
                        // }

                        // Ïú†ÏÇ¨ÎèÑÍ∞Ä ÎÑàÎ¨¥ ÎÇÆÎã§Î©¥ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ Ï∂úÎ†•
                        if (candidate.similarity < 0.3) {
                            const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                            const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                            console.log(`ÎÇÆÏùÄ Ïú†ÏÇ¨ÎèÑ Í∞êÏßÄ:`, {
                                expected: group.expected_answer,
                                candidate: candidate.candidate_word,
                                similarity: candidate.similarity,
                                expectedMag: expectedMag.toFixed(6),
                                candidateMag: candidateMag.toFixed(6)
                            });
                        }
                    }

                    // Ïú†ÏÇ¨ÎèÑÏôÄ ÎπàÎèÑÏàòÎ°ú Ï†ïÎ†¨
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // Í≤∞Í≥º Íµ¨Ï°∞ ÏÉùÏÑ± (Î¨∏Ïû•/Îã®Ïñ¥ ÌÉÄÏûÖÏóê Îî∞Îùº Îã§Î¶Ñ)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞:', JSON.stringify(analysisResults));
                // 4. ÏÑ†ÌÉùÎêú ÌÉÄÏûÖÏóê Îî∞Îùº Í≤∞Í≥º ÌëúÏãú
                if (dataType === 'word') {
                    displayWordResults();
                } else if (dataType === 'sentence') {
                    displaySentenceResults();
                }

            } catch (error) {
                console.error('Î∂ÑÏÑù Ï§ë Ïò§Î•ò:', error);
                document.getElementById('loading').innerHTML = `<div class="error">Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}</div>`;
            }
        }

        // Îã®Ïñ¥Ïö© Í≤∞Í≥º ÌëúÏãú Ìï®Ïàò
        function displayWordResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // Ïú†ÏÇ¨ÎèÑ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÏÉùÏÑ±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    Ï£ºÏöî Ïú†ÏÇ¨ÎèÑ: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ÏÉÅÏÑ∏Î≥¥Í∏∞</button>
                                    <br>
                                    Ï∂úÌòÑÌöüÏàò: ${candidate.frequency}Ìöå |
                                    ÏõêÎ≥∏ÌåêÏ†ï: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>Î™®Îì† Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Í≤∞Í≥º:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>Î∂ÑÏÑù:</strong><br>
                                    ‚Ä¢ ÏµúÍ≥†Ï†ê: ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    ‚Ä¢ ÏµúÏ†ÄÏ†ê: ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    ‚Ä¢ ÌèâÍ∑†: ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    ‚Ä¢ Î∂ÑÏÇ∞: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ÏäπÏù∏</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">Í±∞Ï†à</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id}</h3>
                        <div class="expected">Ï†ïÎãµ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // Î¨∏Ïû•Ïö© Í≤∞Í≥º ÌëúÏãú Ìï®Ïàò
        function displaySentenceResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const keywordClass = candidate.keyword_included ? 'similarity-high' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // Ïú†ÏÇ¨ÎèÑ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÏÉùÏÑ±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word" style="font-size: 0.95rem; line-height: 1.4;">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    ÌÇ§ÏõåÎìú: <strong>${candidate.keyword}</strong> |
                                    ÌÇ§ÏõåÎìú Ìè¨Ìï®: <span class="${keywordClass}">${candidate.keyword_included ? 'YES' : 'NO'}</span>
                                    <br>
                                    Ï£ºÏöî Ïú†ÏÇ¨ÎèÑ: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ÏÉÅÏÑ∏Î≥¥Í∏∞</button>
                                    <br>
                                    Ï∂úÌòÑÌöüÏàò: ${candidate.frequency}Ìöå |
                                    ÏõêÎ≥∏ÌåêÏ†ï: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>Î™®Îì† Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Í≤∞Í≥º:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>Î∂ÑÏÑù:</strong><br>
                                    ‚Ä¢ ÏµúÍ≥†Ï†ê: ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    ‚Ä¢ ÏµúÏ†ÄÏ†ê: ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    ‚Ä¢ ÌèâÍ∑†: ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    ‚Ä¢ Î∂ÑÏÇ∞: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ÏäπÏù∏</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">Í±∞Ï†à</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id} | ÌÇ§ÏõåÎìú: "${result.keyword || result.expected_answer}"</h3>
                        <div class="expected" style="font-size: 0.95rem; line-height: 1.4; margin-top: 10px;">Ï†ïÎãµ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // ÏäπÏù∏ Ï≤òÎ¶¨
        function approveCandidate(candidateId) {
            approvalStatus[candidateId] = 'approved';
            const element = document.getElementById(`candidate_${candidateId}`);
            element.className = 'candidate-item approved';
            console.log(`ÏäπÏù∏Îê®: ${candidateId}`);

            // ÏäπÏù∏/Í±∞Ï†à ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÏµúÏ¢Ö Í≤∞Í≥º Ï∂úÎ†•
            updateFinalResults();
        }

        // Í±∞Ï†à Ï≤òÎ¶¨
        function rejectCandidate(candidateId) {
            approvalStatus[candidateId] = 'rejected';
            const element = document.getElementById(`candidate_${candidateId}`);
            element.className = 'candidate-item rejected';
            console.log(`Í±∞Ï†àÎê®: ${candidateId}`);

            // ÏäπÏù∏/Í±∞Ï†à ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÏµúÏ¢Ö Í≤∞Í≥º Ï∂úÎ†•
            updateFinalResults();
        }

        // ÏµúÏ¢Ö Í≤∞Í≥º ÏóÖÎç∞Ïù¥Ìä∏ (ÏöîÏ≤≠ÌïòÏã† JSON ÌòïÌÉúÎ°ú)
        function updateFinalResults() {
            const finalResults = analysisResults.map(result => {
                const approvedCandidates = result.candidates.filter(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    return approvalStatus[candidateId] === 'approved';
                });

                return {
                    id: result.id,
                    expected_answer: result.expected_answer,
                    candidates: result.candidates.map(candidate => ({
                        log_id: candidate.log_id,
                        candidate_word: candidate.candidate_word,
                        similarity: candidate.similarity,
                        similarities: candidate.similarities, // Î™®Îì† Ïú†ÏÇ¨ÎèÑ Ï†êÏàò Ìè¨Ìï®
                        origin_judge: candidate.origin_judge,
                        frequency: candidate.frequency,
                        approval_status: approvalStatus[`${result.id}_${candidate.candidate_word}`] || 'pending'
                    }))
                };
            });

            console.log('ÏµúÏ¢Ö Í≤∞Í≥º (ÏöîÏ≤≠ ÌòïÌÉú):', JSON.stringify(finalResults, null, 2));
        }

        // Î™®Îì† Í≤∞Í≥º ÏäπÏù∏
        function approveAll() {
            analysisResults.forEach(result => {
                result.candidates.forEach(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    approveCandidate(candidateId);
                });
            });
        }

        // Î™®Îì† Í≤∞Í≥º Í±∞Ï†à
        function rejectAll() {
            analysisResults.forEach(result => {
                result.candidates.forEach(candidate => {
                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    rejectCandidate(candidateId);
                });
            });
        }

        // Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞ (JSON ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìú)
        function exportResults() {
            const finalResults = analysisResults.map(result => {
                return {
                    id: result.id,
                    expected_answer: result.expected_answer,
                    candidates: result.candidates.map(candidate => ({
                        log_id: candidate.log_id,
                        candidate_word: candidate.candidate_word,
                        similarity: candidate.similarity,
                        similarities: candidate.similarities, // Î™®Îì† Ïú†ÏÇ¨ÎèÑ Ï†êÏàò Ìè¨Ìï®
                        origin_judge: candidate.origin_judge,
                        frequency: candidate.frequency,
                        approval_status: approvalStatus[`${result.id}_${candidate.candidate_word}`] || 'pending'
                    }))
                };
            });

            // JSON ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìú
            const dataStr = JSON.stringify(finalResults, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `similarity_analysis_results_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('Í≤∞Í≥ºÍ∞Ä JSON ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Ï°åÏäµÎãàÎã§.');
        }

        // Ïú†ÏÇ¨ÎèÑ ÏÉÅÏÑ∏Ï†ïÎ≥¥ ÌÜ†Í∏Ä Ìï®Ïàò
        function toggleSimilarityDetails(candidateId) {
            const detailsElement = document.getElementById(`similarity_${candidateId}`);
            const toggleButton = event.target;

            if (detailsElement.style.display === 'none') {
                detailsElement.style.display = 'block';
                toggleButton.textContent = 'Ïà®Í∏∞Í∏∞';
            } else {
                detailsElement.style.display = 'none';
                toggleButton.textContent = 'ÏÉÅÏÑ∏Î≥¥Í∏∞';
            }
        }
    </script>
</body>
</html>
