<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë¶„ì„ íŒŒì´í”„ë¼ì¸ - ìœ ì‚¬ì–´ ë¶„ì„</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– AI ë¶„ì„ íŒŒì´í”„ë¼ì¸</h1>
            <p>ìœ ì‚¬ì–´ í›„ë³´ ë¶„ì„ ë° ìŠ¹ì¸/ê±°ì ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API í‚¤</label>
                <input type="password" id="apiKey" placeholder="sk-..." value="">
            </div>

            <div class="input-group">
                <label>ë¶„ì„ ë°ì´í„° íƒ€ì…</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        ë‹¨ì–´
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        ë¬¸ì¥
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API ì‚¬ìš©</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš©
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš© ì•ˆí•¨ (ì „ì²˜ë¦¬ ë° STT íŠ¹í™” ì²˜ë¦¬ë§Œ)
                    </label>
                </div>

                <div id="openaiModelOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0;">
                        OpenAI ì„ë² ë”© ëª¨ë¸ ì„ íƒ
                    </label>
                    <div style="display: flex; flex-direction: row; gap: 5px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-small" checked style="margin-right: 8px;">
                            text-embedding-3-small (ê¸°ë³¸, ë¹ ë¦„, ê²½ì œì )
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-large" style="margin-right: 8px;">
                            text-embedding-3-large (ë” ì •í™•, ëŠë¦¼, ë¹„ìŒˆ)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * text-embedding-3-largeëŠ” ë” ë†’ì€ ì •í™•ë„ë¥¼ ì œê³µí•˜ì§€ë§Œ ë¹„ìš©ê³¼ ì²˜ë¦¬ ì‹œê°„ì´ ë” ë§ì´ ì†Œìš”ë©ë‹ˆë‹¤.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label>ì „ì²˜ë¦¬ ì˜µì…˜</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="true" checked style="margin-right: 8px;flex: 1;">
                        ì „ì²˜ë¦¬ í™œì„±í™”
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="false" style="margin-right: 8px;flex: 1;">
                        ì „ì²˜ë¦¬ ë¹„í™œì„±í™”
                    </label>
                </div>

                <div id="preprocessingStageOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                    <div style="color: #e0e0e0; font-size: 0.9rem; line-height: 1.5; margin-bottom: 15px;">
                        <strong>ì „ì²˜ë¦¬ ë‹¨ê³„:</strong><br>
                        <span style="color: #4fc3f7;">Step 1:</span> í•œê¸€ ìˆ«ì â†’ ì•„ë¼ë¹„ì•„ ìˆ«ì (ì¼â†’1, ì´â†’2, íŒ”â†’8 ë“±)<br>
                        <span style="color: #4fc3f7;">Step 2:</span> ì†Œìˆ˜ì  í‘œí˜„ ì •ê·œí™” (ì /ì©œâ†’., 8ì 9â†’8.9)<br>
                        <span style="color: #4fc3f7;">Step 3:</span> ë‹¨ìœ„ ì •ê·œí™” (mâ†’ë¯¸í„°, %â†’í¼ì„¼íŠ¸, gâ†’ê·¸ë¨ ë“±)<br>
                        <span style="color: #4fc3f7;">Step 4:</span> ìˆ«ì â†’ í•œê¸€ ë³€í™˜ (8.9â†’íŒ”ì êµ¬, 4400â†’ì‚¬ì²œì‚¬ë°±)<br>
                    </div>

                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <strong>ë¶„ì„í•  ì „ì²˜ë¦¬ ë‹¨ê³„ ì„ íƒ:</strong>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="original" checked style="margin-right: 8px;">
                            ì›ë³¸ (ì „ì²˜ë¦¬ ì—†ìŒ)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step13" checked style="margin-right: 8px;">
                            1-3ë‹¨ê³„ (ìˆ«ì ìœ ì§€)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step14" checked style="margin-right: 8px;">
                            1-4ë‹¨ê³„ (í•œê¸€ ë³€í™˜)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * ì„ íƒëœ ë‹¨ê³„ë“¤ì— ëŒ€í•´ì„œë§Œ ì„ë² ë”©ì„ ê³„ì‚°í•˜ê³  ë¹„êµí•©ë‹ˆë‹¤. ìµœì†Œ 1ê°œëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.
                    </div>
                </div>

                <!-- STT íŠ¹í™” ë©”íŠ¸ë¦­ ì˜µì…˜ -->
                <div style="display: flex; align-items: center; margin-top: 15px; padding: 15px; background: #2a2a2a; border-radius: 8px; border-left: 4px solid #4caf50;">
                    <label style="display: flex; align-items: center; font-weight: 600; cursor: pointer;">
                        <input type="checkbox" name="enableSTTMetrics" checked style="margin-right: 12px; transform: scale(1.2);">
                        <span style="color: #4caf50;">ğŸ¯ STT íŠ¹í™” ë©”íŠ¸ë¦­ í™œì„±í™”</span>
                    </label>
                    <div style="position: relative; margin-left: 10px;">
                        <span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: #4caf50; color: white; border-radius: 50%; font-size: 12px; font-weight: bold; cursor: help;">i</span>
                        <div style="position: absolute; top: 25px; left: -150px; background: #333; color: #e0e0e0; padding: 12px; border-radius: 8px; font-size: 0.85rem; line-height: 1.4; width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; z-index: 1000; border: 1px solid #555;">
                            <strong style="color: #4caf50;">ìŒì„± ì¸ì‹ íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚°ì„ ì¶”ê°€ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤:</strong><br><br>
                            â€¢ <strong>Jaro-Winkler</strong>: ë¶€ë¶„ ì¼ì¹˜ ë° ì ‘ë‘ì‚¬ ê°€ì¤‘ì¹˜<br>
                            â€¢ <strong>Levenshtein</strong>: í¸ì§‘ ê±°ë¦¬ ê¸°ë°˜ ìœ ì‚¬ë„<br>
                            â€¢ <strong>Korean Phonetic</strong>: í•œêµ­ì–´ ìŒì„±í•™ì  í˜¼ë™ íŒ¨í„´ (ã…â†”ã…‹, ã…Œâ†”ã„· ë“±)<br>
                            â€¢ <strong>STT Ensemble</strong>: ì„ë² ë”© + STT ë©”íŠ¸ë¦­ ì•™ìƒë¸” ì ìˆ˜
                        </div>
                    </div>
                </div>

                <style>
                .stt-info-container:hover .stt-tooltip {
                    opacity: 1 !important;
                    visibility: visible !important;
                }
                </style>

                <script>
                // STT ì •ë³´ ì•„ì´ì½˜ ì´ë²¤íŠ¸ëŠ” ë©”ì¸ DOMContentLoadedì—ì„œ ì²˜ë¦¬ë¨
                </script>
            </div>

            <div class="input-group">
                <label for="csvData">ë¶„ì„ ë°ì´í„° (CSV/TSV í˜•ì‹)</label>
                <textarea id="csvData" placeholder="ë‹¨ì–´ í˜•íƒœ - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,ìŠ¤ëƒ…ë“œë˜ê³¤ 8,,ìŠ¤ëƒ…ë“œë˜ ê³°íŒŒì—&#10;ë‹¨ì–´ í˜•íƒœ - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		í¬í† 		ì•ˆí‹°&#10;&#10;ë¬¸ì¥ í˜•íƒœ - TSV: 521	3985	18.5	FALSE	ì„¤ëª…	SENTENCE_SIMILARITY_PASS_FAIL_V2	ì•ˆí‹°ë”¥ë³´ì´ìŠ¤		ì›ë³¸ë¬¸ì¥		ì‚¬ìš©ìë‹µë³€ë¬¸ì¥"></textarea>
            </div>

            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" onclick="analyzeData()">ë¶„ì„ ì‹œì‘</button>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="debugLevel" style="color: #e0e0e0; font-weight: 600; white-space: nowrap;">ë¡œê·¸ ë ˆë²¨:</label>
                    <select id="debugLevel" style="padding: 8px; border: 2px solid #555; border-radius: 8px; background: #3a3a3a; color: #e0e0e0; font-size: 14px;">
                        <option value="0">0: ê¸°ë³¸</option>
                        <option value="1" selected>1: ìƒì„¸</option>
                        <option value="2">2: ëª¨ë“  ë¡œê·¸</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <p>ğŸ”„ AIê°€ ë°ì´í„°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">ëª¨ë‘ ìŠ¹ì¸</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">ëª¨ë‘ ê±°ì ˆ</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6; margin-right: 10px;">JSON ë‚´ë³´ë‚´ê¸°</button>
                <button class="btn" onclick="exportExcel()" style="background: #2e7d32; margin-right: 10px;">ğŸ“Š ì—‘ì…€ ë‚´ë³´ë‚´ê¸°</button>
                <button class="btn" onclick="exportPDF()" style="background: #e91e63;">ğŸ“„ PDF ë‚´ë³´ë‚´ê¸°</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- SheetJS ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì—‘ì…€ ìƒì„±ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ (PDF ìƒì„±ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas ë¼ì´ë¸ŒëŸ¬ë¦¬ (HTMLì„ Canvasë¡œ ë³€í™˜) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- config.js ëª¨ë“ˆ ë¡œë“œ (í‚¤ ì„¤ì •) -->
    <script src="./config.js"></script>
    <!-- similarity.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./preprocessing.js"></script>
    <!-- parser.js ëª¨ë“ˆ ë¡œë“œ (ë°ì´í„° íŒŒì‹± ë° ê·¸ë£¹í•‘) -->
    <script src="./parser.js"></script>
    <!-- management.js ëª¨ë“ˆ ë¡œë“œ (ê´€ë¦¬ ê¸°ëŠ¥) -->
    <script src="./management.js"></script>
    <!-- stt-similarity.js ëª¨ë“ˆ ë¡œë“œ (STT íŠ¹í™” ìœ ì‚¬ë„) -->
    <script src="./stt-similarity.js"></script>
    <!-- sentence-similarity.js ëª¨ë“ˆ ë¡œë“œ (ë¬¸ì¥ íŠ¹í™” ìœ ì‚¬ë„) -->
    <script src="./sentence-similarity.js"></script>
    <!-- displayResults.js ëª¨ë“ˆ ë¡œë“œ (ê²°ê³¼ í‘œì‹œ ë° ë Œë”ë§) -->
    <script src="./displayResults.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};

        // ë””ë²„ê·¸ ë ˆë²¨ ì„¤ì • (0: ê¸°ë³¸, 1: ìƒì„¸, 2: ëª¨ë“  ë¡œê·¸)
        function getDebugLevel() {
            const debugSelect = document.getElementById('debugLevel');
            return debugSelect ? parseInt(debugSelect.value) : 2;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ config.jsì—ì„œ API í‚¤ ìë™ ë¡œë“œ
        document.addEventListener('DOMContentLoaded', function() {
            // STT ì •ë³´ ì•„ì´ì½˜ì— hover ì´ë²¤íŠ¸ ì¶”ê°€
            const infoIcon = document.querySelector('div[style*="position: relative"] span');
            const tooltip = document.querySelector('div[style*="position: absolute"]');

            if (infoIcon && tooltip) {
                infoIcon.addEventListener('mouseenter', function() {
                    tooltip.style.opacity = '1';
                    tooltip.style.visibility = 'visible';
                });

                infoIcon.addEventListener('mouseleave', function() {
                    tooltip.style.opacity = '0';
                    tooltip.style.visibility = 'hidden';
                });
            }

            if (typeof CONFIG !== 'undefined' && CONFIG.OPENAI_API_KEY) {
                document.getElementById('apiKey').value = CONFIG.OPENAI_API_KEY;
                console.log('API í‚¤ê°€ config.jsì—ì„œ ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }

            // ëª¨ë“ˆ ë¡œë”© ìƒíƒœ í™•ì¸
            console.log('=== ëª¨ë“ˆ ë¡œë”© ìƒíƒœ í™•ì¸ ===');
            console.log('SimilarityCalculator:', typeof SimilarityCalculator !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('STTSimilarity:', typeof STTSimilarity !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('SentenceSimilarity:', typeof SentenceSimilarity !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('TextPreprocessor:', typeof TextPreprocessor !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('DataParser:', typeof DataParser !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('DisplayResults:', typeof DisplayResults !== 'undefined' ? 'âœ… ë¡œë“œë¨' : 'âŒ ë¡œë“œ ì•ˆë¨');
            console.log('==========================');

            if (typeof SentenceSimilarity !== 'undefined') {
                console.log('SentenceSimilarity ë©”ì„œë“œë“¤:', Object.keys(SentenceSimilarity));
            }

            // ì „ì²˜ë¦¬ ì˜µì…˜ ë³€ê²½ ì‹œ ë‹¨ê³„ ì„ íƒ í‘œì‹œ/ìˆ¨ê¹€
            const preprocessingRadios = document.querySelectorAll('input[name="enablePreprocessing"]');
            const stageOptions = document.getElementById('preprocessingStageOptions');

            function toggleStageOptions() {
                const isEnabled = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
                stageOptions.style.display = isEnabled ? 'block' : 'none';
            }

            preprocessingRadios.forEach(radio => {
                radio.addEventListener('change', toggleStageOptions);
            });

            // OpenAI API ì‚¬ìš© ì˜µì…˜ ë³€ê²½ ì‹œ ëª¨ë¸ ì„ íƒ í‘œì‹œ/ìˆ¨ê¹€
            const openaiRadios = document.querySelectorAll('input[name="useOpenAI"]');
            const modelOptions = document.getElementById('openaiModelOptions');

            function toggleModelOptions() {
                const isOpenAIEnabled = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
                modelOptions.style.display = isOpenAIEnabled ? 'block' : 'none';
            }

            openaiRadios.forEach(radio => {
                radio.addEventListener('change', toggleModelOptions);
            });

            // ì´ˆê¸° ìƒíƒœ ì„¤ì •
            toggleStageOptions();
            toggleModelOptions();
        });






        // í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ í•¨ìˆ˜ (í‚¤ì›Œë“œê°€ ë¬¸ì¥ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ìœ ì‚¬ë„ë¡œ í™•ì¸)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // í‚¤ì›Œë“œì™€ ë¬¸ì¥ì—ì„œ í‚¤ì›Œë“œ ë¶€ë¶„ì„ ì¶”ì¶œí•˜ì—¬ ë¹„êµ
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // ë¬¸ì¥ì„ ë‹¨ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ê° ë‹¨ì–´ì™€ í‚¤ì›Œë“œì˜ ìœ ì‚¬ë„ í™•ì¸
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ ì˜¤ë¥˜:', error);
                // ì˜¤ë¥˜ ì‹œ ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ë¡œ ëŒ€ì²´
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI ì„ë² ë”© API í˜¸ì¶œ (ë‹¨ì¼ í…ìŠ¤íŠ¸)
        async function getEmbedding(text, apiKey) {
            // todo ì¼ë‹¨ ì£¼ì„
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // ë” ë†’ì€ ì°¨ì›ìœ¼ë¡œ ë” ì •í™•í•œ ì„ë² ë”©
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API ì˜¤ë¥˜: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // í…ìŠ¤íŠ¸ ë°°ì—´ ê²€ì¦ ë° ì •ë¦¬ í•¨ìˆ˜
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ ë°°ì—´ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            }

            // 1ë‹¨ê³„: ê¸°ë³¸ í•„í„°ë§
            const basicFiltered = texts
                .filter(text => text != null && typeof text === 'string' && text.trim().length > 0);

            // 2ë‹¨ê³„: ì œì–´ ë¬¸ì ë° íŠ¹ìˆ˜ ë¬¸ì ì •ë¦¬
            const cleanTexts = basicFiltered.map(text =>
                text.replace(/[\x00-\x1F\x7F]/g, '') // ì œì–´ ë¬¸ì ì œê±°
                .replace(/[^\w\sê°€-í£]/g, ' ') // íŠ¹ìˆ˜ ë¬¸ìë¥¼ ê³µë°±ìœ¼ë¡œ ë³€ê²½
                .trim()
            ).filter(text => text.length > 0);

            // 3ë‹¨ê³„: í† í° ê¸¸ì´ ì œí•œ (OpenAI ì œí•œ: 8192 í† í°, ëŒ€ëµ 8192 ë¬¸ìë¡œ ì¶”ì •)
            const finalTexts = cleanTexts.filter(text =>
                text.length > 0 && text.length < 8192
            );

            if (finalTexts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            const removed = texts.length - finalTexts.length;
            if (removed > 0) {
                console.warn(`${removed}ê°œì˜ ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                console.log('ì œê±° ìƒì„¸:', {
                    ì›ë³¸: texts.length,
                    ê¸°ë³¸í•„í„°ë§í›„: basicFiltered.length,
                    ë¬¸ìì •ë¦¬í›„: cleanTexts.length,
                    ìµœì¢…: finalTexts.length
                });
            }

            console.log('ê²€ì¦ëœ í…ìŠ¤íŠ¸ ìƒ˜í”Œ:', finalTexts.slice(0, 3));
            return finalTexts;
        }

        // ë””ë²„ê¹…ìš© í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ í•¨ìˆ˜
        function logTextAnalysis(validTexts) {
            console.log('=== í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ ===');
            console.log('ë°°ì—´ íƒ€ì…:', Array.isArray(validTexts));
            console.log('ë°°ì—´ ê¸¸ì´:', validTexts.length);

            // ê° í…ìŠ¤íŠ¸ì˜ íƒ€ì…ê³¼ ê¸¸ì´ í™•ì¸
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('ì²˜ìŒ 10ê°œ í…ìŠ¤íŠ¸ ë¶„ì„:', textAnalysis);

            // ë¹ˆ ë¬¸ìì—´ì´ë‚˜ ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ì°¾ê¸°
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ë“¤:', problematicTexts);
            }
            console.log('========================');
        }

        // API ìš”ì²­ í˜ì´ë¡œë“œ ë¡œê¹… í•¨ìˆ˜
        function logRequestPayload(requestPayload) {
            console.log('API ìš”ì²­ í˜ì´ë¡œë“œ ë¯¸ë¦¬ë³´ê¸°:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API ì˜¤ë¥˜ ë¡œê¹… í•¨ìˆ˜
        async function logApiError(response, requestPayload) {
            console.error('API ìš”ì²­ ì‹¤íŒ¨!');
            console.error('ì‘ë‹µ ìƒíƒœ:', response.status);
            console.error('ì‘ë‹µ í—¤ë”:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('ì‘ë‹µ ë³¸ë¬¸ (í…ìŠ¤íŠ¸):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('íŒŒì‹±ëœ ì˜¤ë¥˜ ë°ì´í„°:', errorData);
            } catch (parseError) {
                console.error('ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŒ:', parseError);
                errorData = { message: errorText };
            }

            // ìš”ì²­í–ˆë˜ ë°ì´í„°ë„ í•¨ê»˜ ë¡œê¹…
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ input ìƒ˜í”Œ (ì²˜ìŒ 3ê°œ):', requestPayload.input.slice(0, 3));
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ ì „ì²´ í˜ì´ë¡œë“œ:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI ì„ë² ë”© API ë°°ì¹˜ í˜¸ì¶œ (ì—¬ëŸ¬ í…ìŠ¤íŠ¸ë¥¼ ë°°ì¹˜ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬)
        async function getBatchEmbeddings(texts, apiKey, selectedModel = 'text-embedding-3-small') {
            // 1. í…ìŠ¤íŠ¸ ê²€ì¦ ë° ì •ë¦¬
            const validTexts = validateAndCleanTexts(texts);

            // 2. ë””ë²„ê¹… ë¡œê·¸
            console.log('APIë¥¼ í†µí•´ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            console.log(`ìœ íš¨í•œ í…ìŠ¤íŠ¸ ${validTexts.length}ê°œ:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            if (!validTexts || validTexts.length === 0) {
                throw new Error('ì „ì†¡í•  ìœ íš¨í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            // 3. OpenAI API ë°°ì¹˜ í¬ê¸° ì œí•œ (ìµœëŒ€ 2048ê°œ)
            const BATCH_SIZE = 2048;
            const totalBatches = Math.ceil(validTexts.length / BATCH_SIZE);
            const allEmbeddings = [];

            console.log(`ì´ ${validTexts.length}ê°œ í…ìŠ¤íŠ¸ë¥¼ ${totalBatches}ê°œ ë°°ì¹˜ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬í•©ë‹ˆë‹¤.`);

            // 4. ë°°ì¹˜ë³„ë¡œ ìˆœì°¨ ì²˜ë¦¬
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * BATCH_SIZE;
                const endIdx = Math.min(startIdx + BATCH_SIZE, validTexts.length);
                const batchTexts = validTexts.slice(startIdx, endIdx);

                console.log(`ë°°ì¹˜ ${batchIndex + 1}/${totalBatches}: ${batchTexts.length}ê°œ í…ìŠ¤íŠ¸ ì²˜ë¦¬ ì¤‘...`);

                const requestPayload = {
                    model: String(selectedModel).trim(),
                    input: batchTexts.map(String)
                };

                console.log(`ë°°ì¹˜ ${batchIndex + 1} ìš”ì²­:`, {
                    ëª¨ë¸: requestPayload.model,
                    ì…ë ¥ê°œìˆ˜: requestPayload.input.length,
                    ìƒ˜í”Œ: requestPayload.input.slice(0, 3)
                });

                try {
                    // API í˜¸ì¶œ
                    const response = await fetch('https://api.openai.com/v1/embeddings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestPayload)
                    });

                    console.log(`ë°°ì¹˜ ${batchIndex + 1} API ì‘ë‹µ ìƒíƒœ:`, response.status, response.statusText);

                    // ì˜¤ë¥˜ ì²˜ë¦¬
                    if (!response.ok) {
                        const errorData = await logApiError(response, requestPayload);
                        throw new Error(`ë°°ì¹˜ ${batchIndex + 1} OpenAI API ì˜¤ë¥˜: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    // ì„±ê³µ ì‘ë‹µ ì²˜ë¦¬
                    const data = await response.json();
                    const batchEmbeddings = data.data.map(item => item.embedding);

                    allEmbeddings.push(...batchEmbeddings);
                    console.log(`ë°°ì¹˜ ${batchIndex + 1} ì™„ë£Œ: ${batchEmbeddings.length}ê°œ ì„ë² ë”© ì¶”ê°€ (ëˆ„ì : ${allEmbeddings.length}ê°œ)`);

                    // ë‹¤ìŒ ë°°ì¹˜ ì „ì— ì ì‹œ ëŒ€ê¸° (API ë ˆì´íŠ¸ ë¦¬ë¯¸íŠ¸ ê³ ë ¤)
                    if (batchIndex < totalBatches - 1) {
                        console.log('ë‹¤ìŒ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•´ 1ì´ˆ ëŒ€ê¸°...');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                } catch (error) {
                    console.error(`ë°°ì¹˜ ${batchIndex + 1} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:`, error);
                    throw error;
                }
            }

            console.log(`ëª¨ë“  ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: ì´ ${allEmbeddings.length}ê°œ ì„ë² ë”© ë¡œë“œ`);
            return allEmbeddings;
        }

        // ê¸°ì¡´ í•¨ìˆ˜ë“¤ì€ similarity.jsë¡œ ì´ë™ë¨

        // ë©”ì¸ ë¶„ì„ í•¨ìˆ˜
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
            const selectedModel = document.querySelector('input[name="openaiModel"]:checked')?.value || 'text-embedding-3-small';
            const DEBUG_LEVEL = getDebugLevel();

            if (useOpenAI && !apiKey) {
                alert('OpenAI APIë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!csvData) {
                alert('ë¶„ì„í•  ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì „ì²˜ë¦¬ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œ ë‹¨ê³„ ì„ íƒ í™•ì¸
            const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
            if (enablePreprocessing) {
                const selectedStages = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                if (selectedStages.length === 0) {
                    alert('ì „ì²˜ë¦¬ê°€ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œì˜ ë‹¨ê³„ëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.');
                    return;
                }
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° íŒŒì‹±
                let parsedData;
                if (dataType === 'word') {
                    console.log('ë‹¨ì–´ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = DataParser.parseWordData(csvData, DEBUG_LEVEL);
                } else if (dataType === 'sentence') {
                    console.log('ë¬¸ì¥ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = DataParser.parseSentenceData(csvData, DEBUG_LEVEL);
                }
                console.log('íŒŒì‹±ëœ ë°ì´í„°:', JSON.stringify(parsedData));

                // 2. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° ê·¸ë£¹í•‘
                let groupedData;
                if (dataType === 'word') {
                    groupedData = DataParser.groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = DataParser.groupSentenceData(parsedData);
                }
                console.log('ê·¸ë£¹í•‘ëœ ë°ì´í„°:', JSON.stringify(groupedData));

                // 3. ë°°ì¹˜ë¡œ ì„ë² ë”© ê³„ì‚° ë° ìœ ì‚¬ë„ ë¶„ì„
                analysisResults = [];
                let idCounter = 1;

                // ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ í•œ ë²ˆì— ìˆ˜ì§‘
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // í…ìŠ¤íŠ¸ ìœ íš¨ì„± ê²€ì¦ í•¨ìˆ˜
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UIì—ì„œ ì „ì²˜ë¦¬ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
                const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';

                // ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë“¤ ê°€ì ¸ì˜¤ê¸°
                const selectedStages = [];
                if (enablePreprocessing) {
                    const stageCheckboxes = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                    stageCheckboxes.forEach(checkbox => {
                        selectedStages.push(checkbox.value);
                    });

                    // ìµœì†Œ 1ê°œëŠ” ì„ íƒë˜ì–´ì•¼ í•¨
                    if (selectedStages.length === 0) {
                        alert('ì „ì²˜ë¦¬ê°€ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œì˜ ë‹¨ê³„ëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.');
                        return;
                    }
                } else {
                    selectedStages.push('original'); // ì „ì²˜ë¦¬ ë¹„í™œì„±í™” ì‹œ ì›ë³¸ë§Œ
                }

                console.log('ì „ì²˜ë¦¬ ì„¤ì •:', { enablePreprocessing, selectedStages });

                // ì¤‘ë³µ í…ìŠ¤íŠ¸ ê´€ë¦¬ë¥¼ ìœ„í•œ ë§µ (processedText -> embeddingIndex)
                const uniqueTexts = new Map();
                let duplicateCount = 0;

                //// ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì‹œì‘
                /**
                 * ì„ë² ë”© ìƒì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ê³¼ì •
                 *
                 * 1. ì •ë‹µ(expected_answer) í…ìŠ¤íŠ¸ë“¤ì„ ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë³„ë¡œ ìˆ˜ì§‘
                 * 2. ê° ë‹¨ê³„ë³„ë¡œ ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¥¼ allTexts ë°°ì—´ì— ì¶”ê°€
                 * 3. textIndexMapìœ¼ë¡œ ë‚˜ì¤‘ì— ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ì¸ë±ìŠ¤ ë§¤í•‘
                 *
                 * ì´ë ‡ê²Œ ìˆ˜ì§‘ëœ ì •ë‹µ ì„ë² ë”©ë“¤ì€ ë‚˜ì¤‘ì— ì‚¬ìš©ì ë°œí™”ì™€ì˜ ìœ ì‚¬ë„ ê³„ì‚°ì—ì„œ
                 * ê¸°ì¤€ì (reference point)ìœ¼ë¡œ ì‚¬ìš©ë¨
                 */
                // ì •ë‹µë“¤ì„ ì„ íƒëœ ë‹¨ê³„ì— ë”°ë¼ ìˆ˜ì§‘
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                console.log(`ğŸ” ë””ë²„ê·¸: ì •ë‹µ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì‹œì‘ - ì´ ${expectedAnswers.length}ê°œ ì •ë‹µ`);
                console.log('ì •ë‹µë“¤:', expectedAnswers);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        selectedStages.forEach(stage => {
                            let processedText;
                            let stageKey;

                            if (DEBUG_LEVEL >= 2) {
                                console.log('ì„ íƒí•œ ë‹¨ê³„ stage : ', stage)
                            }

                            // ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ì— ë”°ë¼ ì •ë‹µ í…ìŠ¤íŠ¸ ë³€í™˜
                            switch(stage) {
                                case 'original':
                                    processedText = answer.trim();
                                    stageKey = 'original';
                                    break;
                                case 'step13':
                                    processedText = TextPreprocessor.applyBasePreprocessing(answer.trim());
                                    stageKey = 'step13';
                                    break;
                                case 'step14':
                                    processedText = TextPreprocessor.preprocessLearningText(answer.trim(), DEBUG_LEVEL);
                                    stageKey = 'step14';
                                    break;
                                default:
                                    console.warn(`ì•Œ ìˆ˜ ì—†ëŠ” ì „ì²˜ë¦¬ ë‹¨ê³„: ${stage}`);
                                    return;
                            }

                            const keyMapping = `expected_${answer}_${stageKey}`;

                            // ì¤‘ë³µ ê²€ì‚¬: ì´ë¯¸ ë™ì¼í•œ ì „ì²˜ë¦¬ ê²°ê³¼ê°€ ìˆëŠ”ì§€ í™•ì¸
                            if (uniqueTexts.has(processedText)) {
                                // ì¤‘ë³µëœ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ê¸°ì¡´ ì„ë² ë”© ì¸ë±ìŠ¤ ì¬ì‚¬ìš©
                                const existingIndex = uniqueTexts.get(processedText);
                                textIndexMap.set(keyMapping, existingIndex);
                                duplicateCount++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`ì •ë‹µ ${stage} ì¤‘ë³µ ê°ì§€: "${answer}" â†’ "${processedText}" (ê¸°ì¡´ ì¸ë±ìŠ¤ ${existingIndex} ì¬ì‚¬ìš©)`);
                                }
                            } else {
                                // ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ì„ë² ë”© ëŒ€ìƒì— ì¶”ê°€
                                allTexts.push(processedText);
                                uniqueTexts.set(processedText, textIndex);
                                textIndexMap.set(keyMapping, textIndex);
                                textIndex++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`ì •ë‹µ ${stage} ì „ì²˜ë¦¬: "${answer}" â†’ "${processedText}" (ìƒˆ ì¸ë±ìŠ¤ ${textIndex-1})`);
                                }
                            }
                        });
                    } else {
                        console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì •ë‹µ í…ìŠ¤íŠ¸:`, answer);
                    }
                });

                console.log('ì •ë‹µë“¤ > ì„ íƒëœ ë‹¨ê³„ ì „ì²˜ë¦¬ ì ìš© ì™„ë£Œ');

                /**
                 * ì‚¬ìš©ì ë°œí™”(í›„ë³´) í…ìŠ¤íŠ¸ë“¤ì„ ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë³„ë¡œ ìˆ˜ì§‘
                 *
                 * 1. ê° ì •ë‹µ ê·¸ë£¹ì˜ í›„ë³´ë“¤(ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‹µë³€ë“¤)ì„ ìˆœíšŒ
                 * 2. ì •ë‹µê³¼ ë™ì¼í•œ ì „ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì ìš©í•˜ì—¬ ê³µì •í•œ ë¹„êµ í™˜ê²½ ì¡°ì„±
                 * 3. ê° í›„ë³´ì˜ ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¥¼ allTexts ë°°ì—´ì— ì¶”ê°€
                 * 4. textIndexMapìœ¼ë¡œ ë‚˜ì¤‘ì— ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ì¸ë±ìŠ¤ ë§¤í•‘
                 *
                 * ì´ë ‡ê²Œ ìˆ˜ì§‘ëœ í›„ë³´ ì„ë² ë”©ë“¤ì€ ë‚˜ì¤‘ì— í•´ë‹¹ ì •ë‹µ ì„ë² ë”©ê³¼ì˜
                 * ìœ ì‚¬ë„(ê±°ë¦¬/ë°©í–¥) ê³„ì‚°ì—ì„œ ì¸¡ì • ëŒ€ìƒìœ¼ë¡œ ì‚¬ìš©ë¨
                 */
                // ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ë„ ì„ íƒëœ ë‹¨ê³„ì— ë”°ë¼ ìˆ˜ì§‘
                console.log(`ğŸ” ë””ë²„ê·¸: í›„ë³´ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì‹œì‘ - ì´ ${groupedData.length}ê°œ ê·¸ë£¹`);
                groupedData.forEach((group, groupIndex) => {
                    console.log(`ê·¸ë£¹ ${groupIndex + 1}: "${group.expected_answer}" - ${group.candidates.length}ê°œ í›„ë³´`);
                    group.candidates.forEach((candidate, candidateIndex) => {
                        console.log(`  í›„ë³´ ${candidateIndex + 1}: "${candidate.candidate_word}"`);
                    });
                });
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            selectedStages.forEach(stage => {
                                let processedText;
                                let stageKey;

                                // ì •ë‹µê³¼ ë™ì¼í•œ ì „ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì ìš©í•˜ì—¬ ê³µì •í•œ ë¹„êµ
                                switch(stage) {
                                    case 'original':
                                        processedText = candidate.candidate_word.trim();
                                        stageKey = 'original';
                                        break;
                                    case 'step13':
                                        processedText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word.trim());
                                        stageKey = 'step13';
                                        break;
                                    case 'step14':
                                        processedText = TextPreprocessor.preprocessLearningText(candidate.candidate_word.trim(), DEBUG_LEVEL);
                                        stageKey = 'step14';
                                        break;
                                    default:
                                        console.warn(`ì•Œ ìˆ˜ ì—†ëŠ” ì „ì²˜ë¦¬ ë‹¨ê³„: ${stage}`);
                                        return;
                                }

                                const keyMapping = `candidate_${group.expected_answer}_${candidate.candidate_word}_${stageKey}`;

                                // ì¤‘ë³µ ê²€ì‚¬: ì´ë¯¸ ë™ì¼í•œ ì „ì²˜ë¦¬ ê²°ê³¼ê°€ ìˆëŠ”ì§€ í™•ì¸
                                if (uniqueTexts.has(processedText)) {
                                    // ì¤‘ë³µëœ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ê¸°ì¡´ ì„ë² ë”© ì¸ë±ìŠ¤ ì¬ì‚¬ìš©
                                    const existingIndex = uniqueTexts.get(processedText);
                                    textIndexMap.set(keyMapping, existingIndex);
                                    duplicateCount++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`í›„ë³´ ${stage} ì¤‘ë³µ ê°ì§€: "${candidate.candidate_word}" â†’ "${processedText}" (ê¸°ì¡´ ì¸ë±ìŠ¤ ${existingIndex} ì¬ì‚¬ìš©)`);
                                    }
                                } else {
                                    // ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ì„ë² ë”© ëŒ€ìƒì— ì¶”ê°€
                                    allTexts.push(processedText);
                                    uniqueTexts.set(processedText, textIndex);
                                    textIndexMap.set(keyMapping, textIndex);
                                    textIndex++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`í›„ë³´ ${stage} ì „ì²˜ë¦¬: "${candidate.candidate_word}" â†’ "${processedText}" (ìƒˆ ì¸ë±ìŠ¤ ${textIndex-1})`);
                                    }
                                }
                            });
                        } else {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ í›„ë³´ í…ìŠ¤íŠ¸:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ > ì„ íƒëœ ë‹¨ê³„ ì „ì²˜ë¦¬ ì ìš© ì™„ë£Œ');

                // ì¤‘ë³µ ì œê±° ê²°ê³¼ ë¡œê·¸ ì¶œë ¥
                const totalRequested = textIndex + duplicateCount;
                console.log(`=== ì¤‘ë³µ ì œê±° ìµœì í™” ê²°ê³¼ ===`);
                console.log(`ì´ ìš”ì²­ëœ í…ìŠ¤íŠ¸: ${totalRequested}ê°œ`);
                console.log(`ì¤‘ë³µ ì œê±°ëœ í…ìŠ¤íŠ¸: ${duplicateCount}ê°œ`);
                console.log(`ì‹¤ì œ ì„ë² ë”© ì²˜ë¦¬ í…ìŠ¤íŠ¸: ${allTexts.length}ê°œ`);
                console.log(`API í˜¸ì¶œ ì ˆì•½ë¥ : ${(duplicateCount / totalRequested * 100).toFixed(1)}%`);
                console.log('===============================');

                console.log(`ì´ ${allTexts.length}ê°œ ìœ íš¨í•œ í…ìŠ¤íŠ¸ë¥¼ ë°°ì¹˜ë¡œ ì„ë² ë”© ì²˜ë¦¬í•©ë‹ˆë‹¤.`);
                console.log('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë“¤:', allTexts.slice(0, 10).map((text, i) => `${i}: "${text}"`), allTexts.length > 10 ? `... ì™¸ ${allTexts.length - 10}ê°œ` : '');

                // ë¹ˆ í…ìŠ¤íŠ¸ê°€ ìˆëŠ”ì§€ ìµœì¢… í™•ì¸
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`ë¹ˆ í…ìŠ¤íŠ¸ ${emptyTexts.length}ê°œ ë°œê²¬:`, emptyTexts);
                    throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ${emptyTexts.length}ê°œ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
                }

                // ë°°ì¹˜ ìˆ˜ ë¯¸ë¦¬ ê³„ì‚°
                const BATCH_SIZE = 2048; // getBatchEmbeddingsì™€ ë™ì¼í•œ ê°’
                const expectedBatches = Math.ceil(allTexts.length / BATCH_SIZE);
                console.log(`=== ì„ë² ë”© ë°°ì¹˜ ì²˜ë¦¬ ì˜ˆìƒ ===`);
                console.log(`ì´ í…ìŠ¤íŠ¸ ìˆ˜: ${allTexts.length}ê°œ`);
                console.log(`ë°°ì¹˜ í¬ê¸°: ${BATCH_SIZE}ê°œ`);
                console.log(`ì˜ˆìƒ ë°°ì¹˜ ìˆ˜: ${expectedBatches}ê°œ`);
                if (expectedBatches > 1) {
                    console.log(`ë°°ì¹˜ë³„ ë¶„í• :`);
                    for (let i = 0; i < expectedBatches; i++) {
                        const startIdx = i * BATCH_SIZE;
                        const endIdx = Math.min(startIdx + BATCH_SIZE, allTexts.length);
                        const batchSize = endIdx - startIdx;
                        console.log(`  - ë°°ì¹˜ ${i + 1}: ${batchSize}ê°œ (${startIdx + 1}~${endIdx}ë²ˆì§¸)`);
                    }
                }
                console.log(`ì˜ˆìƒ ì²˜ë¦¬ ì‹œê°„: ì•½ ${expectedBatches * 3}ì´ˆ (ë°°ì¹˜ë‹¹ ëŒ€ê¸°ì‹œê°„ í¬í•¨)`);
                console.log('==============================');

                console.log('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë“¤:', allTexts);

                //// ì „ì²˜ë¦¬ ë

                // ğŸ” ë””ë²„ê·¸: allTextsê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
                if (allTexts.length === 0) {
                    console.error('âŒ allTexts ë°°ì—´ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!');
                    console.error('ê·¸ë£¹í™”ëœ ë°ì´í„°:', groupedData);
                    console.error('ì„ íƒëœ ë‹¨ê³„:', selectedStages);
                    console.error('ë°ì´í„° íƒ€ì…:', dataType);
                    throw new Error('ì²˜ë¦¬í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì…ë ¥ ë°ì´í„°ë‚˜ ì „ì²˜ë¦¬ ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                // OpenAI API ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI APIë¥¼ í†µí•œ ì„ë² ë”© ê³„ì‚°
                    console.log(`OpenAI API (${selectedModel})ë¥¼ í†µí•´ ì„ë² ë”©ì„ ê³„ì‚°í•©ë‹ˆë‹¤...`);
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey, selectedModel);
                } else {
                    // OpenAI API ì—†ì´ ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰ - ë”ë¯¸ ì„ë² ë”© ë°ì´í„° ìƒì„±
                    console.log('ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤. OpenAI APIëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');

                    // ë”ë¯¸ ì„ë² ë”© ë°ì´í„° (ëª¨ë“  ê°’ì´ 0.5ì¸ 1024ì°¨ì› ë²¡í„°)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // console.log('ì„ë² ë”© ê²°ê³¼ = allEmbeddings : ', allEmbeddings)

                /**
                 * ìœ ì‚¬ë„ ê³„ì‚° í•µì‹¬ ë¡œì§
                 *
                 * ì´ ë¶€ë¶„ì´ ì „ì²´ ì‹œìŠ¤í…œì˜ í•µì‹¬ìœ¼ë¡œ, ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ì„ ê±°ì¹¨:
                 * 1. ì •ë‹µì˜ ì„ë² ë”©ì„ ê¸°ì¤€ì (reference)ìœ¼ë¡œ ì„¤ì •
                 * 2. ì‚¬ìš©ì ë°œí™”(í›„ë³´)ì˜ ì„ë² ë”©ì„ ì¸¡ì • ëŒ€ìƒ(target)ìœ¼ë¡œ ì„¤ì •
                 * 3. ë‘ ë²¡í„° ê°„ì˜ ê±°ë¦¬ì™€ ë°©í–¥ì„ ë‹¤ì–‘í•œ ìœ ì‚¬ë„ ë©”íŠ¸ë¦­ìœ¼ë¡œ ê³„ì‚°
                 * 4. ê°€ì¥ ë†’ì€ ìœ ì‚¬ë„ë¥¼ ë³´ì´ëŠ” ì „ì²˜ë¦¬ ë°©ë²•ì„ ìµœì  ë°©ë²•ìœ¼ë¡œ ì„ íƒ
                 *
                 * ìœ ì‚¬ë„ ê³„ì‚° ë°©ì‹:
                 * - ì½”ì‚¬ì¸ ìœ ì‚¬ë„: ë²¡í„° ê°„ì˜ ê°ë„(ë°©í–¥)ë¥¼ ì¸¡ì • (0~1, ë†’ì„ìˆ˜ë¡ ìœ ì‚¬)
                 * - ìœ í´ë¦¬ë””ì•ˆ ê±°ë¦¬: ë²¡í„° ê°„ì˜ ì§ì„  ê±°ë¦¬ë¥¼ ì¸¡ì • (ë‚®ì„ìˆ˜ë¡ ìœ ì‚¬)
                 * - ê¸°íƒ€ ë‹¤ì–‘í•œ ê±°ë¦¬/ìœ ì‚¬ë„ ë©”íŠ¸ë¦­ ì ìš©
                 */
                // ê° ê·¸ë£¹ì— ëŒ€í•´ ì„ íƒëœ ë‹¨ê³„ë³„ ìœ ì‚¬ë„ ê³„ì‚°
                for (const group of groupedData) {
                    // ê° í›„ë³´ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                    for (const candidate of group.candidates) {
                        // ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼ë¥¼ ì €ì¥í•  ê°ì²´
                        candidate.preprocessingComparison = {};

                        // ì„ íƒëœ ê° ë‹¨ê³„ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                        const comparisonResults = [];

                        for (const stage of selectedStages) {
                            // ì •ë‹µì˜ ì„ë² ë”© ë²¡í„° ê°€ì ¸ì˜¤ê¸° (ê¸°ì¤€ì  ì—­í• )
                            const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}_${stage}`)];
                            // ì‚¬ìš©ì ë°œí™”ì˜ ì„ë² ë”© ë²¡í„° ê°€ì ¸ì˜¤ê¸° (ì¸¡ì • ëŒ€ìƒ)
                            const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}_${stage}`)];

                            if (expectedEmbedding && candidateEmbedding) {
                                // í•µì‹¬: ì •ë‹µ ì„ë² ë”©ì„ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ì ë°œí™”ì™€ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                                // expectedEmbedding(ê¸°ì¤€ì ) vs candidateEmbedding(ì¸¡ì •ëŒ€ìƒ)

                                // STT ë©”íŠ¸ë¦­ í™œì„±í™” ì—¬ë¶€ í™•ì¸
                                const enableSTT = document.querySelector('input[name="enableSTTMetrics"]:checked');

                                // ê° ë‹¨ê³„ë³„ í…ìŠ¤íŠ¸ ìƒì„± (STT ë©”íŠ¸ë¦­ì„ ìœ„í•´ ë¨¼ì € ìƒì„±)
                                let expectedText, candidateText;
                                switch(stage) {
                                    case 'original':
                                        expectedText = group.expected_answer;
                                        candidateText = candidate.candidate_word;
                                        break;
                                    case 'step13':
                                        expectedText = TextPreprocessor.applyBasePreprocessing(group.expected_answer);
                                        candidateText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word);
                                        break;
                                    case 'step14':
                                        expectedText = TextPreprocessor.preprocessLearningText(group.expected_answer);
                                        candidateText = TextPreprocessor.preprocessLearningText(candidate.candidate_word);
                                        break;
                                }

                                // ìœ ì‚¬ë„ ê³„ì‚° ë¶„ê¸° (ë°ì´í„° íƒ€ì…ë³„ ì°¨ë³„í™”)
                                let similarities;
                                if (dataType === 'sentence') {
                                    // ğŸ¯ ë¬¸ì¥ íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚° (í–¥ìƒëœ ë¡œì§)
                                    // SentenceSimilarity ëª¨ë“ˆ ê°€ìš©ì„± í™•ì¸
                                    if (typeof SentenceSimilarity !== 'undefined' && SentenceSimilarity.calculateSentenceEnhancedSimilarity) {
                                        // ê³µí†µ ë¬¸ì¥ íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚° (OpenAI ì‚¬ìš© ì—¬ë¶€ì™€ ë¬´ê´€)
                                        const sentenceResult = SentenceSimilarity.calculateSentenceEnhancedSimilarity(
                                            expectedEmbedding,
                                            candidateEmbedding,
                                            expectedText,
                                            candidateText,
                                            group.keyword || group.expected_answer
                                        );

                                        if (useOpenAI) {
                                            // OpenAI ì‚¬ìš©: ì •ìƒì ì¸ ë¬¸ì¥ íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚°
                                            similarities = {
                                                cosine: sentenceResult.finalScore,
                                                euclidean: sentenceResult.components.baseSimilarity || 0.5,
                                                manhattan: sentenceResult.components.keywordWeighted || 0.5,
                                                pearson: sentenceResult.components.sttCorrected || 0.5,
                                                jaccard: sentenceResult.components.completeness || 0.5,

                                                // ë¬¸ì¥ íŠ¹í™” ë©”íŠ¸ë¦­ ì¶”ê°€
                                                sentence_enhanced: sentenceResult.finalScore,
                                                sentence_components: sentenceResult.components,
                                                sentence_analysis: sentenceResult.analysis
                                            };
                                        } else {
                                            // OpenAI ë¯¸ì‚¬ìš©: ì„ë² ë”© ê¸°ë°˜ ìœ ì‚¬ë„ëŠ” 0.0ìœ¼ë¡œ ì„¤ì •
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0,

                                                // ë¬¸ì¥ íŠ¹í™” ë©”íŠ¸ë¦­ì€ ìœ ì§€ (í…ìŠ¤íŠ¸ ê¸°ë°˜ ê³„ì‚° í¬í•¨)
                                                sentence_enhanced: 0.0,
                                                sentence_components: {
                                                    baseSimilarity: 0.0,
                                                    keywordWeighted: 0.0,
                                                    sttCorrected: sentenceResult.components.sttCorrected || 0.0,
                                                    completeness: 0.0,
                                                    lengthPenalty: sentenceResult.components.lengthPenalty || 1.0
                                                },
                                                sentence_analysis: sentenceResult.analysis
                                            };
                                        }

                                        // STT ë©”íŠ¸ë¦­ì´ í™œì„±í™”ëœ ê²½ìš° ì¶”ê°€
                                        if (enableSTT) {
                                            // STT ì•™ìƒë¸”: ë‹¨ì–´ìš© STT ë©”íŠ¸ë¦­ë“¤ì˜ ê°€ì¤‘ í‰ê·  ê³„ì‚°
                                            const sttResult = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                            similarities.stt_ensemble = sttResult.stt_ensemble;

                                            // STT Enhanced: OpenAI ì‚¬ìš© ì‹œì—ë§Œ ë¬¸ì¥ íŠ¹í™” ìµœì¢… ì ìˆ˜, ë¯¸ì‚¬ìš© ì‹œì—ëŠ” STT ë©”íŠ¸ë¦­ ìµœê³ ê°’ ì‚¬ìš©
                                            if (useOpenAI) {
                                                similarities.stt_enhanced = sentenceResult.finalScore;
                                            } else {
                                                // OpenAI ë¯¸ì‚¬ìš©: STT ë©”íŠ¸ë¦­ë“¤ ì¤‘ ìµœê³ ê°’ ì‚¬ìš©
                                                const sttValues = [
                                                    sttResult.stt_jaro_winkler || 0,
                                                    sttResult.stt_levenshtein || 0,
                                                    sttResult.stt_phonetic || 0
                                                ];
                                                similarities.stt_enhanced = Math.max(...sttValues);
                                            }
                                        }

                                        // â­ í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ ì—…ë°ì´íŠ¸ (parser.jsì—ì„œ falseë¡œ ì´ˆê¸°í™”ëœ ê°’ ìˆ˜ì •)
                                        if (sentenceResult.analysis && typeof sentenceResult.analysis.keywordIncluded !== 'undefined') {
                                            candidate.keyword_included = sentenceResult.analysis.keywordIncluded;

                                            if (DEBUG_LEVEL >= 2) {
                                                console.log(`í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ ì—…ë°ì´íŠ¸: "${candidate.candidate_word}" â†’ keyword_included: ${candidate.keyword_included}`);
                                            }
                                        }

                                        if (DEBUG_LEVEL >= 2) {
                                            console.log(`ë¬¸ì¥ íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚° ì™„ë£Œ:`, {
                                                keyword: group.keyword,
                                                finalScore: sentenceResult.finalScore,
                                                components: sentenceResult.components,
                                                analysis: sentenceResult.analysis
                                            });
                                        }
                                    } else {
                                        // SentenceSimilarity ëª¨ë“ˆì´ ì—†ëŠ” ê²½ìš° ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ëŒ€ì²´
                                        console.warn('SentenceSimilarity ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ì¡´ ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                                        if (enableSTT) {
                                            similarities = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                        } else {
                                            similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);
                                        }
                                    }
                                } else {
                                    // ê¸°ì¡´ ë‹¨ì–´ ìœ ì‚¬ë„ ê³„ì‚° ë¡œì§ ìœ ì§€
                                    if (enableSTT) {
                                        // STT íŠ¹í™” ìœ ì‚¬ë„ ê³„ì‚° (ì„ë² ë”© + STT ë©”íŠ¸ë¦­)
                                        // ğŸ’¡ STT ë©”íŠ¸ë¦­ì€ í…ìŠ¤íŠ¸ ê¸°ë°˜ì´ë¯€ë¡œ useOpenAIì™€ ë¬´ê´€í•˜ê²Œ ì‘ë™
                                        if (useOpenAI) {
                                            similarities = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                        } else {
                                            // OpenAI ë¯¸ì‚¬ìš©: ì„ë² ë”© ê¸°ë°˜ ìœ ì‚¬ë„ëŠ” 0.0, STT ë©”íŠ¸ë¦­ë§Œ ê³„ì‚°
                                            const sttOnlyResult = SimilarityCalculator.calculateSTTEnhancedSimilarities(
                                                expectedEmbedding,
                                                candidateEmbedding,
                                                expectedText,
                                                candidateText
                                            );
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0,
                                                // STT ë©”íŠ¸ë¦­ì€ ìœ ì§€ (í…ìŠ¤íŠ¸ ê¸°ë°˜)
                                                stt_ensemble: sttOnlyResult.stt_ensemble,
                                                stt_enhanced: sttOnlyResult.stt_enhanced,
                                                jaroWinkler: sttOnlyResult.jaroWinkler,
                                                levenshtein: sttOnlyResult.levenshtein,
                                                phonetic: sttOnlyResult.phonetic
                                            };
                                        }
                                    } else {
                                        if (useOpenAI) {
                                            // ê¸°ì¡´ ë°©ì‹ (ì„ë² ë”©ë§Œ)
                                            similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);
                                        } else {
                                            // OpenAI ë¯¸ì‚¬ìš©: ëª¨ë“  ì„ë² ë”© ê¸°ë°˜ ìœ ì‚¬ë„ 0.0
                                            similarities = {
                                                cosine: 0.0,
                                                euclidean: 0.0,
                                                manhattan: 0.0,
                                                pearson: 0.0,
                                                jaccard: 0.0
                                            };
                                        }
                                    }
                                }

                                candidate.preprocessingComparison[stage] = {
                                    similarity: similarities.cosine,
                                    similarities: similarities,
                                    expectedText: expectedText,
                                    candidateText: candidateText
                                };

                                // ë¬¸ì¥ ë°ì´í„°ì˜ ê²½ìš° ê¸°ì¡´ ìœ ì‚¬ë„ ë©”íŠ¸ë¦­ ì¤‘ ìµœê³ ê°’ ì„ íƒ
                                let primarySimilarity = similarities.cosine;
                                if (dataType === 'sentence') {
                                    const basicSimilarityMethods = ['cosine', 'euclidean', 'manhattan', 'pearson', 'jaccard'];
                                    const basicSimilarities = basicSimilarityMethods
                                        .filter(method => similarities[method] !== undefined)
                                        .map(method => ({method, value: similarities[method]}));

                                    if (basicSimilarities.length > 0) {
                                        const highest = basicSimilarities.reduce((max, curr) =>
                                            curr.value > max.value ? curr : max
                                        );
                                        primarySimilarity = highest.value;

                                        if (DEBUG_LEVEL >= 2) {
                                            console.log(`ë¬¸ì¥ ìµœê³  ìœ ì‚¬ë„ ì„ íƒ: ${highest.method} = ${highest.value.toFixed(6)}`);
                                        }
                                    }
                                }

                                comparisonResults.push({
                                    name: stage,
                                    similarity: primarySimilarity,
                                    similarities: similarities
                                });

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`${group.expected_answer} vs ${candidate.candidate_word} (${stage}): ${similarities.cosine.toFixed(3)}`);
                                }

                                // ìœ ì‚¬ë„ê°€ ë„ˆë¬´ ë‚®ë‹¤ë©´ ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
                                if (similarities.cosine < 0.3) {
                                    const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                                    const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                                    console.log(`ë‚®ì€ ìœ ì‚¬ë„ ê°ì§€ (${stage}):`, {
                                        expected: group.expected_answer,
                                        candidate: candidate.candidate_word,
                                        stage: stage,
                                        similarity: similarities.cosine,
                                        expectedMag: expectedMag.toFixed(6),
                                        candidateMag: candidateMag.toFixed(6)
                                    });
                                }
                            } else {
                                console.warn(`ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${stage} ë‹¨ê³„`);
                            }
                        }

                        // ê°€ì¥ ë†’ì€ ìœ ì‚¬ë„ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
                        if (comparisonResults.length > 0) {
                            const bestComparison = comparisonResults.sort((a, b) => b.similarity - a.similarity)[0];
                            candidate.similarities = bestComparison.similarities;
                            candidate.similarity = bestComparison.similarity;
                            candidate.bestPreprocessingMethod = bestComparison.name;
                        } else {
                            console.warn('ìœ íš¨í•œ ë¹„êµ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                            candidate.similarities = {};
                            candidate.similarity = 0;
                            candidate.bestPreprocessingMethod = 'none';
                        }

                    }

                    // ìœ ì‚¬ë„ì™€ ë¹ˆë„ìˆ˜ë¡œ ì •ë ¬
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // ê²°ê³¼ êµ¬ì¡° ìƒì„± (ë¬¸ì¥/ë‹¨ì–´ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¦„)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('ê²°ê³¼ ë°ì´í„°:', JSON.stringify(analysisResults));
                // 4. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ê²°ê³¼ í‘œì‹œ
                if (dataType === 'word') {
                    DisplayResults.displayWordResults(analysisResults, approvalStatus);
                } else if (dataType === 'sentence') {
                    DisplayResults.displaySentenceResults(analysisResults, approvalStatus);
                }

            } catch (error) {
                console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
                document.getElementById('loading').innerHTML = `<div class="error">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}</div>`;
            }
        }


    </script>
</body>
</html>


