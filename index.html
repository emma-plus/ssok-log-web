<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ë¶„ì„ íŒŒì´í”„ë¼ì¸ - ìœ ì‚¬ì–´ ë¶„ì„</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– AI ë¶„ì„ íŒŒì´í”„ë¼ì¸</h1>
            <p>ìœ ì‚¬ì–´ í›„ë³´ ë¶„ì„ ë° ìŠ¹ì¸/ê±°ì ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API í‚¤</label>
                <input type="password" id="apiKey" placeholder="sk-..." value="">
            </div>

            <div class="input-group">
                <label>ë¶„ì„ ë°ì´í„° íƒ€ì…</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        ë‹¨ì–´
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        ë¬¸ì¥
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API ì‚¬ìš©</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš©
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        ì‚¬ìš© ì•ˆí•¨ (ì „ì²˜ë¦¬ë§Œ)
                    </label>
                </div>

                <div id="openaiModelOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0;">
                        OpenAI ì„ë² ë”© ëª¨ë¸ ì„ íƒ
                    </label>
                    <div style="display: flex; flex-direction: row; gap: 5px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-small" checked style="margin-right: 8px;">
                            text-embedding-3-small (ê¸°ë³¸, ë¹ ë¦„, ê²½ì œì )
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-large" style="margin-right: 8px;">
                            text-embedding-3-large (ë” ì •í™•, ëŠë¦¼, ë¹„ìŒˆ)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * text-embedding-3-largeëŠ” ë” ë†’ì€ ì •í™•ë„ë¥¼ ì œê³µí•˜ì§€ë§Œ ë¹„ìš©ê³¼ ì²˜ë¦¬ ì‹œê°„ì´ ë” ë§ì´ ì†Œìš”ë©ë‹ˆë‹¤.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label>ì „ì²˜ë¦¬ ì˜µì…˜</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="true" checked style="margin-right: 8px;flex: 1;">
                        ì „ì²˜ë¦¬ í™œì„±í™”
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="false" style="margin-right: 8px;flex: 1;">
                        ì „ì²˜ë¦¬ ë¹„í™œì„±í™”
                    </label>
                </div>

                <div id="preprocessingStageOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                    <div style="color: #e0e0e0; font-size: 0.9rem; line-height: 1.5; margin-bottom: 15px;">
                        <strong>ì „ì²˜ë¦¬ ë‹¨ê³„:</strong><br>
                        <span style="color: #4fc3f7;">Step 1:</span> í•œê¸€ ìˆ«ì â†’ ì•„ë¼ë¹„ì•„ ìˆ«ì (ì¼â†’1, ì´â†’2, íŒ”â†’8 ë“±)<br>
                        <span style="color: #4fc3f7;">Step 2:</span> ì†Œìˆ˜ì  í‘œí˜„ ì •ê·œí™” (ì /ì©œâ†’., 8ì 9â†’8.9)<br>
                        <span style="color: #4fc3f7;">Step 3:</span> ë‹¨ìœ„ ì •ê·œí™” (mâ†’ë¯¸í„°, %â†’í¼ì„¼íŠ¸, gâ†’ê·¸ë¨ ë“±)<br>
                        <span style="color: #4fc3f7;">Step 4:</span> ìˆ«ì â†’ í•œê¸€ ë³€í™˜ (8.9â†’íŒ”ì êµ¬, 4400â†’ì‚¬ì²œì‚¬ë°±)
                    </div>

                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <strong>ë¶„ì„í•  ì „ì²˜ë¦¬ ë‹¨ê³„ ì„ íƒ:</strong>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="original" checked style="margin-right: 8px;">
                            ì›ë³¸ (ì „ì²˜ë¦¬ ì—†ìŒ)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step13" checked style="margin-right: 8px;">
                            1-3ë‹¨ê³„ (ìˆ«ì ìœ ì§€)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step14" checked style="margin-right: 8px;">
                            1-4ë‹¨ê³„ (í•œê¸€ ë³€í™˜)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * ì„ íƒëœ ë‹¨ê³„ë“¤ì— ëŒ€í•´ì„œë§Œ ì„ë² ë”©ì„ ê³„ì‚°í•˜ê³  ë¹„êµí•©ë‹ˆë‹¤. ìµœì†Œ 1ê°œëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label for="csvData">ë¶„ì„ ë°ì´í„° (CSV/TSV í˜•ì‹)</label>
                <textarea id="csvData" placeholder="ë‹¨ì–´ í˜•íƒœ - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,ìŠ¤ëƒ…ë“œë˜ê³¤ 8,,ìŠ¤ëƒ…ë“œë˜ ê³°íŒŒì—&#10;ë‹¨ì–´ í˜•íƒœ - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		í¬í† 		ì•ˆí‹°&#10;&#10;ë¬¸ì¥ í˜•íƒœ - TSV: 521	3985	18.5	FALSE	ì„¤ëª…	SENTENCE_SIMILARITY_PASS_FAIL_V2	ì•ˆí‹°ë”¥ë³´ì´ìŠ¤		ì›ë³¸ë¬¸ì¥		ì‚¬ìš©ìë‹µë³€ë¬¸ì¥"></textarea>
            </div>

            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" onclick="analyzeData()">ë¶„ì„ ì‹œì‘</button>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="debugLevel" style="color: #e0e0e0; font-weight: 600; white-space: nowrap;">ë¡œê·¸ ë ˆë²¨:</label>
                    <select id="debugLevel" style="padding: 8px; border: 2px solid #555; border-radius: 8px; background: #3a3a3a; color: #e0e0e0; font-size: 14px;">
                        <option value="0">0: ê¸°ë³¸</option>
                        <option value="1" selected>1: ìƒì„¸</option>
                        <option value="2">2: ëª¨ë“  ë¡œê·¸</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <p>ğŸ”„ AIê°€ ë°ì´í„°ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">ëª¨ë‘ ìŠ¹ì¸</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">ëª¨ë‘ ê±°ì ˆ</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6; margin-right: 10px;">JSON ë‚´ë³´ë‚´ê¸°</button>
                <button class="btn" onclick="exportExcel()" style="background: #2e7d32;">ğŸ“Š ì—‘ì…€ ë‚´ë³´ë‚´ê¸°</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- SheetJS ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì—‘ì…€ ìƒì„±ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- config.js ëª¨ë“ˆ ë¡œë“œ (í‚¤ ì„¤ì •) -->
    <script src="./config.js"></script>
    <!-- similarity.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js ëª¨ë“ˆ ë¡œë“œ -->
    <script src="./preprocessing.js"></script>
    <!-- management.js ëª¨ë“ˆ ë¡œë“œ (ê´€ë¦¬ ê¸°ëŠ¥) -->
    <script src="./management.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};
        let originalInputData = []; // ì›ë³¸ ì…ë ¥ ë°ì´í„° ì €ì¥

        // ë””ë²„ê·¸ ë ˆë²¨ ì„¤ì • (0: ê¸°ë³¸, 1: ìƒì„¸, 2: ëª¨ë“  ë¡œê·¸)
        function getDebugLevel() {
            const debugSelect = document.getElementById('debugLevel');
            return debugSelect ? parseInt(debugSelect.value) : 2;
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ config.jsì—ì„œ API í‚¤ ìë™ ë¡œë“œ
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof CONFIG !== 'undefined' && CONFIG.OPENAI_API_KEY) {
                document.getElementById('apiKey').value = CONFIG.OPENAI_API_KEY;
                console.log('API í‚¤ê°€ config.jsì—ì„œ ìë™ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }

            // ì „ì²˜ë¦¬ ì˜µì…˜ ë³€ê²½ ì‹œ ë‹¨ê³„ ì„ íƒ í‘œì‹œ/ìˆ¨ê¹€
            const preprocessingRadios = document.querySelectorAll('input[name="enablePreprocessing"]');
            const stageOptions = document.getElementById('preprocessingStageOptions');

            function toggleStageOptions() {
                const isEnabled = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
                stageOptions.style.display = isEnabled ? 'block' : 'none';
            }

            preprocessingRadios.forEach(radio => {
                radio.addEventListener('change', toggleStageOptions);
            });

            // OpenAI API ì‚¬ìš© ì˜µì…˜ ë³€ê²½ ì‹œ ëª¨ë¸ ì„ íƒ í‘œì‹œ/ìˆ¨ê¹€
            const openaiRadios = document.querySelectorAll('input[name="useOpenAI"]');
            const modelOptions = document.getElementById('openaiModelOptions');

            function toggleModelOptions() {
                const isOpenAIEnabled = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
                modelOptions.style.display = isOpenAIEnabled ? 'block' : 'none';
            }

            openaiRadios.forEach(radio => {
                radio.addEventListener('change', toggleModelOptions);
            });

            // ì´ˆê¸° ìƒíƒœ ì„¤ì •
            toggleStageOptions();
            toggleModelOptions();
        });


        // CSV/TSV ë‹¨ì–´ ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜
        function parseWordData(dataText, debugLevel = 2) {
            const lines = dataText.trim().split('\n');
            const data = [];
            originalInputData = []; // ì›ë³¸ ë°ì´í„° ì´ˆê¸°í™”

            // ì¹´ìš´í„° ë³€ìˆ˜ë“¤
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // ë°ì´í„° í˜•íƒœ ìë™ ê°ì§€ (ì²« ë²ˆì§¸ ìœ íš¨í•œ ë¼ì¸ìœ¼ë¡œ íŒë‹¨)
            let delimiter = ','; // ê¸°ë³¸ê°’ì€ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // íƒ­ê³¼ ì‰¼í‘œ ê°œìˆ˜ë¥¼ ì„¸ì–´ì„œ ë” ë§ì€ ìª½ìœ¼ë¡œ ê²°ì •
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } else {
                        delimiter = ',';
                        console.log('CSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ë¹ˆ ì¤„ ì²´í¬
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // ì£¼ì„ ë¼ì¸ ì²´í¬
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`ì£¼ì„ ë¼ì¸ ê±´ë„ˆë›°ê¸°: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        answer: parts[7].trim(),
                        user_answer: parts[9].trim()
                    });

                    // ì›ë³¸ ì…ë ¥ ë°ì´í„° ì €ì¥
                    originalInputData.push({
                        row_number: originalInputData.length + 1,
                        id: parts[0]?.trim() || '',
                        user_id: parts[1]?.trim() || '',
                        data_type: 'word',
                        version: parts[2]?.trim() || '',
                        pass: parts[3]?.trim() || '',
                        fail_reason: parts[4]?.trim() || '',
                        prompt_type: parts[5]?.trim() || '',
                        keywords: parts[6]?.trim() || '',
                        word: parts[7]?.trim() || '',
                        sentence: parts[8]?.trim() || '',
                        user_response: parts[9]?.trim() || '',
                        parsing_status: 'ì„±ê³µ',
                        original_line: trimmedLine
                    });
                } else {
                    skippedInvalidLines++;
                    if (debugLevel >= 1) {
                        console.log(`ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸ (ì»¬ëŸ¼ ìˆ˜ ë¶€ì¡±): ${trimmedLine}`);
                    }

                }
            }

            console.log('=== íŒŒì‹± ê²°ê³¼ ìš”ì•½ ===');
            console.log(`ì „ì²´ ë¼ì¸ ìˆ˜: ${totalLines}`);
            console.log(`ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ëœ ë ˆì½”ë“œ: ${data.length}`);
            console.log(`ê±´ë„ˆë›´ ë¹ˆ ì¤„: ${skippedEmptyLines}`);
            console.log(`ê±´ë„ˆë›´ ì£¼ì„ ë¼ì¸: ${skippedCommentLines}`);
            console.log(`ê±´ë„ˆë›´ ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸: ${skippedInvalidLines}`);
            console.log(`ì‚¬ìš©ëœ êµ¬ë¶„ì: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // CSV/TSV ë¬¸ì¥ ë°ì´í„°ë¥¼ íŒŒì‹±í•˜ëŠ” í•¨ìˆ˜
        function parseSentenceData(dataText, debugLevel = 2) {
            const lines = dataText.trim().split('\n');
            const data = [];
            originalInputData = []; // ì›ë³¸ ë°ì´í„° ì´ˆê¸°í™”

            // ì¹´ìš´í„° ë³€ìˆ˜ë“¤
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // ë°ì´í„° í˜•íƒœ ìë™ ê°ì§€ (ì²« ë²ˆì§¸ ìœ íš¨í•œ ë¼ì¸ìœ¼ë¡œ íŒë‹¨)
            let delimiter = ','; // ê¸°ë³¸ê°’ì€ CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // íƒ­ê³¼ ì‰¼í‘œ ê°œìˆ˜ë¥¼ ì„¸ì–´ì„œ ë” ë§ì€ ìª½ìœ¼ë¡œ ê²°ì •
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    } else {
                        delimiter = ',';
                        console.log('CSV í˜•íƒœë¡œ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // ë¹ˆ ì¤„ ì²´í¬
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // ì£¼ì„ ë¼ì¸ ì²´í¬
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`ì£¼ì„ ë¼ì¸ ê±´ë„ˆë›°ê¸°: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                // ë¬¸ì¥ ë°ì´í„°ëŠ” ìµœì†Œ 10ê°œ ì»¬ëŸ¼ì´ í•„ìš” (id, user_id, version, judge, description, type, keyword, empty, original_sentence, user_sentence)
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        version: parts[2].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        description: parts[4].trim(),
                        type: parts[5].trim(),
                        keyword: parts[6].trim(),
                        empty1: parts[7].trim(),
                        answer: parts[8].trim(), // ì›ë³¸ ë¬¸ì¥
                        user_answer: parts[9].trim() // ì‚¬ìš©ì ë‹µë³€ ë¬¸ì¥
                    });

                    // ì›ë³¸ ì…ë ¥ ë°ì´í„° ì €ì¥
                    originalInputData.push({
                        row_number: originalInputData.length + 1,
                        id: parts[0]?.trim() || '',
                        user_id: parts[1]?.trim() || '',
                        data_type: 'sentence',
                        version: parts[2]?.trim() || '',
                        pass: parts[3]?.trim() || '',
                        fail_reason: parts[4]?.trim() || '',
                        prompt_type: parts[5]?.trim() || '',
                        keywords: parts[6]?.trim() || '',
                        word: parts[7]?.trim() || '',
                        sentence: parts[8]?.trim() || '',
                        user_response: parts[9]?.trim() || '',
                        parsing_status: 'ì„±ê³µ',
                        original_line: trimmedLine
                    });
                } else {
                    skippedInvalidLines++;
                    if (debugLevel >= 1) {
                        console.log(`ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸ (ì»¬ëŸ¼ ìˆ˜ ë¶€ì¡±): ${trimmedLine}`);
                    }
                }
            }

            console.log('=== ë¬¸ì¥ ë°ì´í„° íŒŒì‹± ê²°ê³¼ ìš”ì•½ ===');
            console.log(`ì „ì²´ ë¼ì¸ ìˆ˜: ${totalLines}`);
            console.log(`ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ëœ ë ˆì½”ë“œ: ${data.length}`);
            console.log(`ê±´ë„ˆë›´ ë¹ˆ ì¤„: ${skippedEmptyLines}`);
            console.log(`ê±´ë„ˆë›´ ì£¼ì„ ë¼ì¸: ${skippedCommentLines}`);
            console.log(`ê±´ë„ˆë›´ ìœ íš¨í•˜ì§€ ì•Šì€ ë¼ì¸: ${skippedInvalidLines}`);
            console.log(`ì‚¬ìš©ëœ êµ¬ë¶„ì: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // ë‹¨ì–´ ë°ì´í„°ë¥¼ ê·¸ë£¹í•‘í•˜ëŠ” í•¨ìˆ˜ (expected_answerë³„ë¡œ ê·¸ë£¹í•‘)
        function groupWordData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer) continue;

                const key = row.answer;
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        candidates: []
                    };
                }

                // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ ê¸°ì¡´ í›„ë³´ ì¤‘ì—ì„œ ê°™ì€ user_answerê°€ ìˆëŠ”ì§€ í™•ì¸
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        similarity: 0, // ì„ë² ë”© ê³„ì‚° í›„ ì—…ë°ì´íŠ¸
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // ë¬¸ì¥ ë°ì´í„°ë¥¼ ê·¸ë£¹í•‘í•˜ëŠ” í•¨ìˆ˜ (í‚¤ì›Œë“œë³„ë¡œ ê·¸ë£¹í•‘)
        function groupSentenceData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer || !row.keyword) continue;

                const key = row.keyword; // í‚¤ì›Œë“œë¡œ ê·¸ë£¹í•‘
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        keyword: row.keyword,
                        candidates: []
                    };
                }

                // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ ê¸°ì¡´ í›„ë³´ ì¤‘ì—ì„œ ê°™ì€ user_answerê°€ ìˆëŠ”ì§€ í™•ì¸
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        keyword: row.keyword,
                        keyword_included: false, // í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ (ë‚˜ì¤‘ì— ê³„ì‚°)
                        similarity: 0, // ì„ë² ë”© ê³„ì‚° í›„ ì—…ë°ì´íŠ¸
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ í•¨ìˆ˜ (í‚¤ì›Œë“œê°€ ë¬¸ì¥ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ìœ ì‚¬ë„ë¡œ í™•ì¸)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // í‚¤ì›Œë“œì™€ ë¬¸ì¥ì—ì„œ í‚¤ì›Œë“œ ë¶€ë¶„ì„ ì¶”ì¶œí•˜ì—¬ ë¹„êµ
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // ë¬¸ì¥ì„ ë‹¨ì–´ë¡œ ë¶„ë¦¬í•˜ì—¬ ê° ë‹¨ì–´ì™€ í‚¤ì›Œë“œì˜ ìœ ì‚¬ë„ í™•ì¸
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('í‚¤ì›Œë“œ ìœ ì‚¬ë„ ê²€ì¦ ì˜¤ë¥˜:', error);
                // ì˜¤ë¥˜ ì‹œ ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ë¡œ ëŒ€ì²´
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI ì„ë² ë”© API í˜¸ì¶œ (ë‹¨ì¼ í…ìŠ¤íŠ¸)
        async function getEmbedding(text, apiKey) {
            // todo ì¼ë‹¨ ì£¼ì„
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // ë” ë†’ì€ ì°¨ì›ìœ¼ë¡œ ë” ì •í™•í•œ ì„ë² ë”©
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API ì˜¤ë¥˜: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // í…ìŠ¤íŠ¸ ë°°ì—´ ê²€ì¦ ë° ì •ë¦¬ í•¨ìˆ˜
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ ë°°ì—´ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            }

            // 1ë‹¨ê³„: ê¸°ë³¸ í•„í„°ë§
            const basicFiltered = texts
                .filter(text => text != null && typeof text === 'string' && text.trim().length > 0);

            // 2ë‹¨ê³„: ì œì–´ ë¬¸ì ë° íŠ¹ìˆ˜ ë¬¸ì ì •ë¦¬
            const cleanTexts = basicFiltered.map(text =>
                text.replace(/[\x00-\x1F\x7F]/g, '') // ì œì–´ ë¬¸ì ì œê±°
                .replace(/[^\w\sê°€-í£]/g, ' ') // íŠ¹ìˆ˜ ë¬¸ìë¥¼ ê³µë°±ìœ¼ë¡œ ë³€ê²½
                .trim()
            ).filter(text => text.length > 0);

            // 3ë‹¨ê³„: í† í° ê¸¸ì´ ì œí•œ (OpenAI ì œí•œ: 8192 í† í°, ëŒ€ëµ 8192 ë¬¸ìë¡œ ì¶”ì •)
            const finalTexts = cleanTexts.filter(text =>
                text.length > 0 && text.length < 8192
            );

            if (finalTexts.length === 0) {
                throw new Error('ìœ íš¨í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            const removed = texts.length - finalTexts.length;
            if (removed > 0) {
                console.warn(`${removed}ê°œì˜ ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                console.log('ì œê±° ìƒì„¸:', {
                    ì›ë³¸: texts.length,
                    ê¸°ë³¸í•„í„°ë§í›„: basicFiltered.length,
                    ë¬¸ìì •ë¦¬í›„: cleanTexts.length,
                    ìµœì¢…: finalTexts.length
                });
            }

            console.log('ê²€ì¦ëœ í…ìŠ¤íŠ¸ ìƒ˜í”Œ:', finalTexts.slice(0, 3));
            return finalTexts;
        }

        // ë””ë²„ê¹…ìš© í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ í•¨ìˆ˜
        function logTextAnalysis(validTexts) {
            console.log('=== í…ìŠ¤íŠ¸ ë°°ì—´ ë¶„ì„ ===');
            console.log('ë°°ì—´ íƒ€ì…:', Array.isArray(validTexts));
            console.log('ë°°ì—´ ê¸¸ì´:', validTexts.length);

            // ê° í…ìŠ¤íŠ¸ì˜ íƒ€ì…ê³¼ ê¸¸ì´ í™•ì¸
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('ì²˜ìŒ 10ê°œ í…ìŠ¤íŠ¸ ë¶„ì„:', textAnalysis);

            // ë¹ˆ ë¬¸ìì—´ì´ë‚˜ ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ ì°¾ê¸°
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” í…ìŠ¤íŠ¸ë“¤:', problematicTexts);
            }
            console.log('========================');
        }

        // API ìš”ì²­ í˜ì´ë¡œë“œ ë¡œê¹… í•¨ìˆ˜
        function logRequestPayload(requestPayload) {
            console.log('API ìš”ì²­ í˜ì´ë¡œë“œ ë¯¸ë¦¬ë³´ê¸°:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API ì˜¤ë¥˜ ë¡œê¹… í•¨ìˆ˜
        async function logApiError(response, requestPayload) {
            console.error('API ìš”ì²­ ì‹¤íŒ¨!');
            console.error('ì‘ë‹µ ìƒíƒœ:', response.status);
            console.error('ì‘ë‹µ í—¤ë”:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('ì‘ë‹µ ë³¸ë¬¸ (í…ìŠ¤íŠ¸):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('íŒŒì‹±ëœ ì˜¤ë¥˜ ë°ì´í„°:', errorData);
            } catch (parseError) {
                console.error('ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹±í•  ìˆ˜ ì—†ìŒ:', parseError);
                errorData = { message: errorText };
            }

            // ìš”ì²­í–ˆë˜ ë°ì´í„°ë„ í•¨ê»˜ ë¡œê¹…
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ input ìƒ˜í”Œ (ì²˜ìŒ 3ê°œ):', requestPayload.input.slice(0, 3));
            console.error('ì‹¤íŒ¨í•œ ìš”ì²­ì˜ ì „ì²´ í˜ì´ë¡œë“œ:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI ì„ë² ë”© API ë°°ì¹˜ í˜¸ì¶œ (ì—¬ëŸ¬ í…ìŠ¤íŠ¸ë¥¼ ë°°ì¹˜ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬)
        async function getBatchEmbeddings(texts, apiKey, selectedModel = 'text-embedding-3-small') {
            // 1. í…ìŠ¤íŠ¸ ê²€ì¦ ë° ì •ë¦¬
            const validTexts = validateAndCleanTexts(texts);

            // 2. ë””ë²„ê¹… ë¡œê·¸
            console.log('APIë¥¼ í†µí•´ ì„ë² ë”© ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤...');
            console.log(`ìœ íš¨í•œ í…ìŠ¤íŠ¸ ${validTexts.length}ê°œ:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            if (!validTexts || validTexts.length === 0) {
                throw new Error('ì „ì†¡í•  ìœ íš¨í•œ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            }

            // 3. OpenAI API ë°°ì¹˜ í¬ê¸° ì œí•œ (ìµœëŒ€ 2048ê°œ)
            const BATCH_SIZE = 2048;
            const totalBatches = Math.ceil(validTexts.length / BATCH_SIZE);
            const allEmbeddings = [];

            console.log(`ì´ ${validTexts.length}ê°œ í…ìŠ¤íŠ¸ë¥¼ ${totalBatches}ê°œ ë°°ì¹˜ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬í•©ë‹ˆë‹¤.`);

            // 4. ë°°ì¹˜ë³„ë¡œ ìˆœì°¨ ì²˜ë¦¬
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * BATCH_SIZE;
                const endIdx = Math.min(startIdx + BATCH_SIZE, validTexts.length);
                const batchTexts = validTexts.slice(startIdx, endIdx);

                console.log(`ë°°ì¹˜ ${batchIndex + 1}/${totalBatches}: ${batchTexts.length}ê°œ í…ìŠ¤íŠ¸ ì²˜ë¦¬ ì¤‘...`);

                const requestPayload = {
                    model: String(selectedModel).trim(),
                    input: batchTexts.map(String)
                };

                console.log(`ë°°ì¹˜ ${batchIndex + 1} ìš”ì²­:`, {
                    ëª¨ë¸: requestPayload.model,
                    ì…ë ¥ê°œìˆ˜: requestPayload.input.length,
                    ìƒ˜í”Œ: requestPayload.input.slice(0, 3)
                });

                try {
                    // API í˜¸ì¶œ
                    const response = await fetch('https://api.openai.com/v1/embeddings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestPayload)
                    });

                    console.log(`ë°°ì¹˜ ${batchIndex + 1} API ì‘ë‹µ ìƒíƒœ:`, response.status, response.statusText);

                    // ì˜¤ë¥˜ ì²˜ë¦¬
                    if (!response.ok) {
                        const errorData = await logApiError(response, requestPayload);
                        throw new Error(`ë°°ì¹˜ ${batchIndex + 1} OpenAI API ì˜¤ë¥˜: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    // ì„±ê³µ ì‘ë‹µ ì²˜ë¦¬
                    const data = await response.json();
                    const batchEmbeddings = data.data.map(item => item.embedding);

                    allEmbeddings.push(...batchEmbeddings);
                    console.log(`ë°°ì¹˜ ${batchIndex + 1} ì™„ë£Œ: ${batchEmbeddings.length}ê°œ ì„ë² ë”© ì¶”ê°€ (ëˆ„ì : ${allEmbeddings.length}ê°œ)`);

                    // ë‹¤ìŒ ë°°ì¹˜ ì „ì— ì ì‹œ ëŒ€ê¸° (API ë ˆì´íŠ¸ ë¦¬ë¯¸íŠ¸ ê³ ë ¤)
                    if (batchIndex < totalBatches - 1) {
                        console.log('ë‹¤ìŒ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•´ 1ì´ˆ ëŒ€ê¸°...');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                } catch (error) {
                    console.error(`ë°°ì¹˜ ${batchIndex + 1} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:`, error);
                    throw error;
                }
            }

            console.log(`ëª¨ë“  ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ: ì´ ${allEmbeddings.length}ê°œ ì„ë² ë”© ë¡œë“œ`);
            return allEmbeddings;
        }

        // ê¸°ì¡´ í•¨ìˆ˜ë“¤ì€ similarity.jsë¡œ ì´ë™ë¨

        // ë©”ì¸ ë¶„ì„ í•¨ìˆ˜
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
            const selectedModel = document.querySelector('input[name="openaiModel"]:checked')?.value || 'text-embedding-3-small';
            const DEBUG_LEVEL = getDebugLevel();

            if (useOpenAI && !apiKey) {
                alert('OpenAI APIë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!csvData) {
                alert('ë¶„ì„í•  ë°ì´í„°ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì „ì²˜ë¦¬ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œ ë‹¨ê³„ ì„ íƒ í™•ì¸
            const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
            if (enablePreprocessing) {
                const selectedStages = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                if (selectedStages.length === 0) {
                    alert('ì „ì²˜ë¦¬ê°€ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œì˜ ë‹¨ê³„ëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.');
                    return;
                }
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° íŒŒì‹±
                let parsedData;
                if (dataType === 'word') {
                    console.log('ë‹¨ì–´ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = parseWordData(csvData, DEBUG_LEVEL);
                } else if (dataType === 'sentence') {
                    console.log('ë¬¸ì¥ ë°ì´í„° íŒŒì‹± ì‹œì‘...');
                    parsedData = parseSentenceData(csvData, DEBUG_LEVEL);
                }
                console.log('íŒŒì‹±ëœ ë°ì´í„°:', JSON.stringify(parsedData));

                // 2. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ë°ì´í„° ê·¸ë£¹í•‘
                let groupedData;
                if (dataType === 'word') {
                    groupedData = groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = groupSentenceData(parsedData);
                }
                console.log('ê·¸ë£¹í•‘ëœ ë°ì´í„°:', JSON.stringify(groupedData));

                // 3. ë°°ì¹˜ë¡œ ì„ë² ë”© ê³„ì‚° ë° ìœ ì‚¬ë„ ë¶„ì„
                analysisResults = [];
                let idCounter = 1;

                // ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ í•œ ë²ˆì— ìˆ˜ì§‘
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // í…ìŠ¤íŠ¸ ìœ íš¨ì„± ê²€ì¦ í•¨ìˆ˜
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UIì—ì„œ ì „ì²˜ë¦¬ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
                const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';

                // ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë“¤ ê°€ì ¸ì˜¤ê¸°
                const selectedStages = [];
                if (enablePreprocessing) {
                    const stageCheckboxes = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                    stageCheckboxes.forEach(checkbox => {
                        selectedStages.push(checkbox.value);
                    });

                    // ìµœì†Œ 1ê°œëŠ” ì„ íƒë˜ì–´ì•¼ í•¨
                    if (selectedStages.length === 0) {
                        alert('ì „ì²˜ë¦¬ê°€ í™œì„±í™”ëœ ê²½ìš° ìµœì†Œ 1ê°œì˜ ë‹¨ê³„ëŠ” ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.');
                        return;
                    }
                } else {
                    selectedStages.push('original'); // ì „ì²˜ë¦¬ ë¹„í™œì„±í™” ì‹œ ì›ë³¸ë§Œ
                }

                console.log('ì „ì²˜ë¦¬ ì„¤ì •:', { enablePreprocessing, selectedStages });

                // ì¤‘ë³µ í…ìŠ¤íŠ¸ ê´€ë¦¬ë¥¼ ìœ„í•œ ë§µ (processedText -> embeddingIndex)
                const uniqueTexts = new Map();
                let duplicateCount = 0;

                //// ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì‹œì‘
                /**
                 * ì„ë² ë”© ìƒì„±ì„ ìœ„í•œ í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ê³¼ì •
                 *
                 * 1. ì •ë‹µ(expected_answer) í…ìŠ¤íŠ¸ë“¤ì„ ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë³„ë¡œ ìˆ˜ì§‘
                 * 2. ê° ë‹¨ê³„ë³„ë¡œ ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¥¼ allTexts ë°°ì—´ì— ì¶”ê°€
                 * 3. textIndexMapìœ¼ë¡œ ë‚˜ì¤‘ì— ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ì¸ë±ìŠ¤ ë§¤í•‘
                 *
                 * ì´ë ‡ê²Œ ìˆ˜ì§‘ëœ ì •ë‹µ ì„ë² ë”©ë“¤ì€ ë‚˜ì¤‘ì— ì‚¬ìš©ì ë°œí™”ì™€ì˜ ìœ ì‚¬ë„ ê³„ì‚°ì—ì„œ
                 * ê¸°ì¤€ì (reference point)ìœ¼ë¡œ ì‚¬ìš©ë¨
                 */
                // ì •ë‹µë“¤ì„ ì„ íƒëœ ë‹¨ê³„ì— ë”°ë¼ ìˆ˜ì§‘
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        selectedStages.forEach(stage => {
                            let processedText;
                            let stageKey;

                            if (DEBUG_LEVEL >= 2) {
                                console.log('ì„ íƒí•œ ë‹¨ê³„ stage : ', stage)
                            }

                            // ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ì— ë”°ë¼ ì •ë‹µ í…ìŠ¤íŠ¸ ë³€í™˜
                            switch(stage) {
                                case 'original':
                                    processedText = answer.trim();
                                    stageKey = 'original';
                                    break;
                                case 'step13':
                                    processedText = TextPreprocessor.applyBasePreprocessing(answer.trim());
                                    stageKey = 'step13';
                                    break;
                                case 'step14':
                                    processedText = TextPreprocessor.preprocessLearningText(answer.trim(), DEBUG_LEVEL);
                                    stageKey = 'step14';
                                    break;
                                default:
                                    console.warn(`ì•Œ ìˆ˜ ì—†ëŠ” ì „ì²˜ë¦¬ ë‹¨ê³„: ${stage}`);
                                    return;
                            }

                            const keyMapping = `expected_${answer}_${stageKey}`;

                            // ì¤‘ë³µ ê²€ì‚¬: ì´ë¯¸ ë™ì¼í•œ ì „ì²˜ë¦¬ ê²°ê³¼ê°€ ìˆëŠ”ì§€ í™•ì¸
                            if (uniqueTexts.has(processedText)) {
                                // ì¤‘ë³µëœ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ê¸°ì¡´ ì„ë² ë”© ì¸ë±ìŠ¤ ì¬ì‚¬ìš©
                                const existingIndex = uniqueTexts.get(processedText);
                                textIndexMap.set(keyMapping, existingIndex);
                                duplicateCount++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`ì •ë‹µ ${stage} ì¤‘ë³µ ê°ì§€: "${answer}" â†’ "${processedText}" (ê¸°ì¡´ ì¸ë±ìŠ¤ ${existingIndex} ì¬ì‚¬ìš©)`);
                                }
                            } else {
                                // ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ì„ë² ë”© ëŒ€ìƒì— ì¶”ê°€
                                allTexts.push(processedText);
                                uniqueTexts.set(processedText, textIndex);
                                textIndexMap.set(keyMapping, textIndex);
                                textIndex++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`ì •ë‹µ ${stage} ì „ì²˜ë¦¬: "${answer}" â†’ "${processedText}" (ìƒˆ ì¸ë±ìŠ¤ ${textIndex-1})`);
                                }
                            }
                        });
                    } else {
                        console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì •ë‹µ í…ìŠ¤íŠ¸:`, answer);
                    }
                });

                console.log('ì •ë‹µë“¤ > ì„ íƒëœ ë‹¨ê³„ ì „ì²˜ë¦¬ ì ìš© ì™„ë£Œ');

                /**
                 * ì‚¬ìš©ì ë°œí™”(í›„ë³´) í…ìŠ¤íŠ¸ë“¤ì„ ì„ íƒëœ ì „ì²˜ë¦¬ ë‹¨ê³„ë³„ë¡œ ìˆ˜ì§‘
                 *
                 * 1. ê° ì •ë‹µ ê·¸ë£¹ì˜ í›„ë³´ë“¤(ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‹µë³€ë“¤)ì„ ìˆœíšŒ
                 * 2. ì •ë‹µê³¼ ë™ì¼í•œ ì „ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì ìš©í•˜ì—¬ ê³µì •í•œ ë¹„êµ í™˜ê²½ ì¡°ì„±
                 * 3. ê° í›„ë³´ì˜ ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¥¼ allTexts ë°°ì—´ì— ì¶”ê°€
                 * 4. textIndexMapìœ¼ë¡œ ë‚˜ì¤‘ì— ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ìˆë„ë¡ ì¸ë±ìŠ¤ ë§¤í•‘
                 *
                 * ì´ë ‡ê²Œ ìˆ˜ì§‘ëœ í›„ë³´ ì„ë² ë”©ë“¤ì€ ë‚˜ì¤‘ì— í•´ë‹¹ ì •ë‹µ ì„ë² ë”©ê³¼ì˜
                 * ìœ ì‚¬ë„(ê±°ë¦¬/ë°©í–¥) ê³„ì‚°ì—ì„œ ì¸¡ì • ëŒ€ìƒìœ¼ë¡œ ì‚¬ìš©ë¨
                 */
                // ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ë„ ì„ íƒëœ ë‹¨ê³„ì— ë”°ë¼ ìˆ˜ì§‘
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            selectedStages.forEach(stage => {
                                let processedText;
                                let stageKey;

                                // ì •ë‹µê³¼ ë™ì¼í•œ ì „ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì ìš©í•˜ì—¬ ê³µì •í•œ ë¹„êµ
                                switch(stage) {
                                    case 'original':
                                        processedText = candidate.candidate_word.trim();
                                        stageKey = 'original';
                                        break;
                                    case 'step13':
                                        processedText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word.trim());
                                        stageKey = 'step13';
                                        break;
                                    case 'step14':
                                        processedText = TextPreprocessor.preprocessLearningText(candidate.candidate_word.trim(), DEBUG_LEVEL);
                                        stageKey = 'step14';
                                        break;
                                    default:
                                        console.warn(`ì•Œ ìˆ˜ ì—†ëŠ” ì „ì²˜ë¦¬ ë‹¨ê³„: ${stage}`);
                                        return;
                                }

                                const keyMapping = `candidate_${group.expected_answer}_${candidate.candidate_word}_${stageKey}`;

                                // ì¤‘ë³µ ê²€ì‚¬: ì´ë¯¸ ë™ì¼í•œ ì „ì²˜ë¦¬ ê²°ê³¼ê°€ ìˆëŠ”ì§€ í™•ì¸
                                if (uniqueTexts.has(processedText)) {
                                    // ì¤‘ë³µëœ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ê¸°ì¡´ ì„ë² ë”© ì¸ë±ìŠ¤ ì¬ì‚¬ìš©
                                    const existingIndex = uniqueTexts.get(processedText);
                                    textIndexMap.set(keyMapping, existingIndex);
                                    duplicateCount++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`í›„ë³´ ${stage} ì¤‘ë³µ ê°ì§€: "${candidate.candidate_word}" â†’ "${processedText}" (ê¸°ì¡´ ì¸ë±ìŠ¤ ${existingIndex} ì¬ì‚¬ìš©)`);
                                    }
                                } else {
                                    // ìƒˆë¡œìš´ í…ìŠ¤íŠ¸ì¸ ê²½ìš°, ì„ë² ë”© ëŒ€ìƒì— ì¶”ê°€
                                    allTexts.push(processedText);
                                    uniqueTexts.set(processedText, textIndex);
                                    textIndexMap.set(keyMapping, textIndex);
                                    textIndex++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`í›„ë³´ ${stage} ì „ì²˜ë¦¬: "${candidate.candidate_word}" â†’ "${processedText}" (ìƒˆ ì¸ë±ìŠ¤ ${textIndex-1})`);
                                    }
                                }
                            });
                        } else {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ í›„ë³´ í…ìŠ¤íŠ¸:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('ëª¨ë“  í›„ë³´ ë‹¨ì–´ë“¤ > ì„ íƒëœ ë‹¨ê³„ ì „ì²˜ë¦¬ ì ìš© ì™„ë£Œ');

                // ì¤‘ë³µ ì œê±° ê²°ê³¼ ë¡œê·¸ ì¶œë ¥
                const totalRequested = textIndex + duplicateCount;
                console.log(`=== ì¤‘ë³µ ì œê±° ìµœì í™” ê²°ê³¼ ===`);
                console.log(`ì´ ìš”ì²­ëœ í…ìŠ¤íŠ¸: ${totalRequested}ê°œ`);
                console.log(`ì¤‘ë³µ ì œê±°ëœ í…ìŠ¤íŠ¸: ${duplicateCount}ê°œ`);
                console.log(`ì‹¤ì œ ì„ë² ë”© ì²˜ë¦¬ í…ìŠ¤íŠ¸: ${allTexts.length}ê°œ`);
                console.log(`API í˜¸ì¶œ ì ˆì•½ë¥ : ${(duplicateCount / totalRequested * 100).toFixed(1)}%`);
                console.log('===============================');

                console.log(`ì´ ${allTexts.length}ê°œ ìœ íš¨í•œ í…ìŠ¤íŠ¸ë¥¼ ë°°ì¹˜ë¡œ ì„ë² ë”© ì²˜ë¦¬í•©ë‹ˆë‹¤.`);
                console.log('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë“¤:', allTexts.slice(0, 10).map((text, i) => `${i}: "${text}"`), allTexts.length > 10 ? `... ì™¸ ${allTexts.length - 10}ê°œ` : '');

                // ë¹ˆ í…ìŠ¤íŠ¸ê°€ ìˆëŠ”ì§€ ìµœì¢… í™•ì¸
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`ë¹ˆ í…ìŠ¤íŠ¸ ${emptyTexts.length}ê°œ ë°œê²¬:`, emptyTexts);
                    throw new Error(`ìœ íš¨í•˜ì§€ ì•Šì€ í…ìŠ¤íŠ¸ê°€ ${emptyTexts.length}ê°œ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
                }

                // ë°°ì¹˜ ìˆ˜ ë¯¸ë¦¬ ê³„ì‚°
                const BATCH_SIZE = 2048; // getBatchEmbeddingsì™€ ë™ì¼í•œ ê°’
                const expectedBatches = Math.ceil(allTexts.length / BATCH_SIZE);
                console.log(`=== ì„ë² ë”© ë°°ì¹˜ ì²˜ë¦¬ ì˜ˆìƒ ===`);
                console.log(`ì´ í…ìŠ¤íŠ¸ ìˆ˜: ${allTexts.length}ê°œ`);
                console.log(`ë°°ì¹˜ í¬ê¸°: ${BATCH_SIZE}ê°œ`);
                console.log(`ì˜ˆìƒ ë°°ì¹˜ ìˆ˜: ${expectedBatches}ê°œ`);
                if (expectedBatches > 1) {
                    console.log(`ë°°ì¹˜ë³„ ë¶„í• :`);
                    for (let i = 0; i < expectedBatches; i++) {
                        const startIdx = i * BATCH_SIZE;
                        const endIdx = Math.min(startIdx + BATCH_SIZE, allTexts.length);
                        const batchSize = endIdx - startIdx;
                        console.log(`  - ë°°ì¹˜ ${i + 1}: ${batchSize}ê°œ (${startIdx + 1}~${endIdx}ë²ˆì§¸)`);
                    }
                }
                console.log(`ì˜ˆìƒ ì²˜ë¦¬ ì‹œê°„: ì•½ ${expectedBatches * 3}ì´ˆ (ë°°ì¹˜ë‹¹ ëŒ€ê¸°ì‹œê°„ í¬í•¨)`);
                console.log('==============================');

                console.log('ì „ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë“¤:', allTexts);

                //// ì „ì²˜ë¦¬ ë

                // OpenAI API ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI APIë¥¼ í†µí•œ ì„ë² ë”© ê³„ì‚°
                    console.log(`OpenAI API (${selectedModel})ë¥¼ í†µí•´ ì„ë² ë”©ì„ ê³„ì‚°í•©ë‹ˆë‹¤...`);
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey, selectedModel);
                } else {
                    // OpenAI API ì—†ì´ ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰ - ë”ë¯¸ ì„ë² ë”© ë°ì´í„° ìƒì„±
                    console.log('ì „ì²˜ë¦¬ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤. OpenAI APIëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');

                    // ë”ë¯¸ ì„ë² ë”© ë°ì´í„° (ëª¨ë“  ê°’ì´ 0.5ì¸ 1024ì°¨ì› ë²¡í„°)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // console.log('ì„ë² ë”© ê²°ê³¼ = allEmbeddings : ', allEmbeddings)

                /**
                 * ìœ ì‚¬ë„ ê³„ì‚° í•µì‹¬ ë¡œì§
                 *
                 * ì´ ë¶€ë¶„ì´ ì „ì²´ ì‹œìŠ¤í…œì˜ í•µì‹¬ìœ¼ë¡œ, ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ì„ ê±°ì¹¨:
                 * 1. ì •ë‹µì˜ ì„ë² ë”©ì„ ê¸°ì¤€ì (reference)ìœ¼ë¡œ ì„¤ì •
                 * 2. ì‚¬ìš©ì ë°œí™”(í›„ë³´)ì˜ ì„ë² ë”©ì„ ì¸¡ì • ëŒ€ìƒ(target)ìœ¼ë¡œ ì„¤ì •
                 * 3. ë‘ ë²¡í„° ê°„ì˜ ê±°ë¦¬ì™€ ë°©í–¥ì„ ë‹¤ì–‘í•œ ìœ ì‚¬ë„ ë©”íŠ¸ë¦­ìœ¼ë¡œ ê³„ì‚°
                 * 4. ê°€ì¥ ë†’ì€ ìœ ì‚¬ë„ë¥¼ ë³´ì´ëŠ” ì „ì²˜ë¦¬ ë°©ë²•ì„ ìµœì  ë°©ë²•ìœ¼ë¡œ ì„ íƒ
                 *
                 * ìœ ì‚¬ë„ ê³„ì‚° ë°©ì‹:
                 * - ì½”ì‚¬ì¸ ìœ ì‚¬ë„: ë²¡í„° ê°„ì˜ ê°ë„(ë°©í–¥)ë¥¼ ì¸¡ì • (0~1, ë†’ì„ìˆ˜ë¡ ìœ ì‚¬)
                 * - ìœ í´ë¦¬ë””ì•ˆ ê±°ë¦¬: ë²¡í„° ê°„ì˜ ì§ì„  ê±°ë¦¬ë¥¼ ì¸¡ì • (ë‚®ì„ìˆ˜ë¡ ìœ ì‚¬)
                 * - ê¸°íƒ€ ë‹¤ì–‘í•œ ê±°ë¦¬/ìœ ì‚¬ë„ ë©”íŠ¸ë¦­ ì ìš©
                 */
                // ê° ê·¸ë£¹ì— ëŒ€í•´ ì„ íƒëœ ë‹¨ê³„ë³„ ìœ ì‚¬ë„ ê³„ì‚°
                for (const group of groupedData) {
                    // ê° í›„ë³´ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                    for (const candidate of group.candidates) {
                        // ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼ë¥¼ ì €ì¥í•  ê°ì²´
                        candidate.preprocessingComparison = {};

                        // ì„ íƒëœ ê° ë‹¨ê³„ì— ëŒ€í•´ ìœ ì‚¬ë„ ê³„ì‚°
                        const comparisonResults = [];

                        for (const stage of selectedStages) {
                            // ì •ë‹µì˜ ì„ë² ë”© ë²¡í„° ê°€ì ¸ì˜¤ê¸° (ê¸°ì¤€ì  ì—­í• )
                            const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}_${stage}`)];
                            // ì‚¬ìš©ì ë°œí™”ì˜ ì„ë² ë”© ë²¡í„° ê°€ì ¸ì˜¤ê¸° (ì¸¡ì • ëŒ€ìƒ)
                            const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}_${stage}`)];

                            if (expectedEmbedding && candidateEmbedding) {
                                // í•µì‹¬: ì •ë‹µ ì„ë² ë”©ì„ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ì ë°œí™”ì™€ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                                // expectedEmbedding(ê¸°ì¤€ì ) vs candidateEmbedding(ì¸¡ì •ëŒ€ìƒ)
                                const similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);

                                // ê° ë‹¨ê³„ë³„ í…ìŠ¤íŠ¸ ìƒì„±
                                let expectedText, candidateText;
                                switch(stage) {
                                    case 'original':
                                        expectedText = group.expected_answer;
                                        candidateText = candidate.candidate_word;
                                        break;
                                    case 'step13':
                                        expectedText = TextPreprocessor.applyBasePreprocessing(group.expected_answer);
                                        candidateText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word);
                                        break;
                                    case 'step14':
                                        expectedText = TextPreprocessor.preprocessLearningText(group.expected_answer);
                                        candidateText = TextPreprocessor.preprocessLearningText(candidate.candidate_word);
                                        break;
                                }

                                candidate.preprocessingComparison[stage] = {
                                    similarity: similarities.cosine,
                                    similarities: similarities,
                                    expectedText: expectedText,
                                    candidateText: candidateText
                                };

                                comparisonResults.push({
                                    name: stage,
                                    similarity: similarities.cosine,
                                    similarities: similarities
                                });

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`${group.expected_answer} vs ${candidate.candidate_word} (${stage}): ${similarities.cosine.toFixed(3)}`);
                                }

                                // ìœ ì‚¬ë„ê°€ ë„ˆë¬´ ë‚®ë‹¤ë©´ ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
                                if (similarities.cosine < 0.3) {
                                    const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                                    const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                                    console.log(`ë‚®ì€ ìœ ì‚¬ë„ ê°ì§€ (${stage}):`, {
                                        expected: group.expected_answer,
                                        candidate: candidate.candidate_word,
                                        stage: stage,
                                        similarity: similarities.cosine,
                                        expectedMag: expectedMag.toFixed(6),
                                        candidateMag: candidateMag.toFixed(6)
                                    });
                                }
                            } else {
                                console.warn(`ì„ë² ë”©ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${stage} ë‹¨ê³„`);
                            }
                        }

                        // ê°€ì¥ ë†’ì€ ìœ ì‚¬ë„ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
                        if (comparisonResults.length > 0) {
                            const bestComparison = comparisonResults.sort((a, b) => b.similarity - a.similarity)[0];
                            candidate.similarities = bestComparison.similarities;
                            candidate.similarity = bestComparison.similarity;
                            candidate.bestPreprocessingMethod = bestComparison.name;
                        } else {
                            console.warn('ìœ íš¨í•œ ë¹„êµ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                            candidate.similarities = {};
                            candidate.similarity = 0;
                            candidate.bestPreprocessingMethod = 'none';
                        }

                        // todo test - checkKeywordSimilarity ì¼ë‹¨ íŒ¨ìŠ¤
                        // // ë¬¸ì¥ íƒ€ì…ì¸ ê²½ìš° í‚¤ì›Œë“œ í¬í•¨ ì—¬ë¶€ í™•ì¸
                        // if (dataType === 'sentence' && candidate.keyword) {
                        //     candidate.keyword_included = await checkKeywordSimilarity(candidate.keyword, candidate.candidate_word, apiKey);
                        // }

                    }

                    // ìœ ì‚¬ë„ì™€ ë¹ˆë„ìˆ˜ë¡œ ì •ë ¬
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // ê²°ê³¼ êµ¬ì¡° ìƒì„± (ë¬¸ì¥/ë‹¨ì–´ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¦„)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('ê²°ê³¼ ë°ì´í„°:', JSON.stringify(analysisResults));
                // 4. ì„ íƒëœ íƒ€ì…ì— ë”°ë¼ ê²°ê³¼ í‘œì‹œ
                if (dataType === 'word') {
                    displayWordResults();
                } else if (dataType === 'sentence') {
                    displaySentenceResults();
                }

            } catch (error) {
                console.error('ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
                document.getElementById('loading').innerHTML = `<div class="error">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}</div>`;
            }
        }

        // ë‹¨ì–´ìš© ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displayWordResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // ìœ ì‚¬ë„ ìƒì„¸ ì •ë³´ ìƒì„±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    // ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼ HTML ìƒì„± (ì„ íƒëœ ë‹¨ê³„ë§Œ)
                    let preprocessingComparisonHTML = '';
                    if (candidate.preprocessingComparison && Object.keys(candidate.preprocessingComparison).length > 0) {
                        const stageNames = {
                            'original': 'ì›ë³¸',
                            'step13': '1-3ë‹¨ê³„',
                            'step14': '1-4ë‹¨ê³„'
                        };

                        preprocessingComparisonHTML = `
                            <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
                                <strong>ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼:</strong><br>
                                ${Object.keys(candidate.preprocessingComparison).map(stage => {
                                    const comparison = candidate.preprocessingComparison[stage];
                                    const stageName = stageNames[stage] || stage;
                                    const isBest = candidate.bestPreprocessingMethod === stage;
                                    return `
                                        <span class="similarity-method${isBest ? ' best' : ''}">${stageName}: ${comparison.similarity.toFixed(3)}</span>
                                        <span style="color: #888; font-size: 0.8rem;">
                                            ("${comparison.expectedText}" vs "${comparison.candidateText}")
                                        </span><br>
                                    `;
                                }).join('')}
                                ${candidate.bestPreprocessingMethod ? `
                                    <span style="color: #4fc3f7; font-weight: bold; margin-top: 5px; display: block;">
                                        ìµœì  ë°©ë²•: ${stageNames[candidate.bestPreprocessingMethod] || candidate.bestPreprocessingMethod}
                                    </span>
                                ` : ''}
                            </div>
                        `;
                    }

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    ì£¼ìš” ìœ ì‚¬ë„: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ìƒì„¸ë³´ê¸°</button>
                                    <br>
                                    ì¶œí˜„íšŸìˆ˜: ${candidate.frequency}íšŒ |
                                    ì›ë³¸íŒì •: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>ëª¨ë“  ìœ ì‚¬ë„ ê³„ì‚° ê²°ê³¼:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>ë¶„ì„:</strong><br>
                                    â€¢ ìµœê³ ì : ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    â€¢ ìµœì €ì : ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    â€¢ í‰ê· : ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    â€¢ ë¶„ì‚°: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                    ${preprocessingComparisonHTML}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ìŠ¹ì¸</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">ê±°ì ˆ</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id}</h3>
                        <div class="expected">ì •ë‹µ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // ë¬¸ì¥ìš© ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function displaySentenceResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const keywordClass = candidate.keyword_included ? 'similarity-high' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // ìœ ì‚¬ë„ ìƒì„¸ ì •ë³´ ìƒì„±
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    // ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼ HTML ìƒì„± (ì„ íƒëœ ë‹¨ê³„ë§Œ)
                    let preprocessingComparisonHTML = '';
                    if (candidate.preprocessingComparison && Object.keys(candidate.preprocessingComparison).length > 0) {
                        const stageNames = {
                            'original': 'ì›ë³¸',
                            'step13': '1-3ë‹¨ê³„',
                            'step14': '1-4ë‹¨ê³„'
                        };

                        preprocessingComparisonHTML = `
                            <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
                                <strong>ì „ì²˜ë¦¬ ë¹„êµ ê²°ê³¼:</strong><br>
                                ${Object.keys(candidate.preprocessingComparison).map(stage => {
                                    const comparison = candidate.preprocessingComparison[stage];
                                    const stageName = stageNames[stage] || stage;
                                    const isBest = candidate.bestPreprocessingMethod === stage;
                                    return `
                                        <span class="similarity-method${isBest ? ' best' : ''}">${stageName}: ${comparison.similarity.toFixed(3)}</span>
                                        <span style="color: #888; font-size: 0.8rem;">
                                            ("${comparison.expectedText}" vs "${comparison.candidateText}")
                                        </span><br>
                                    `;
                                }).join('')}
                                ${candidate.bestPreprocessingMethod ? `
                                    <span style="color: #4fc3f7; font-weight: bold; margin-top: 5px; display: block;">
                                        ìµœì  ë°©ë²•: ${stageNames[candidate.bestPreprocessingMethod] || candidate.bestPreprocessingMethod}
                                    </span>
                                ` : ''}
                            </div>
                        `;
                    }

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word" style="font-size: 0.95rem; line-height: 1.4;">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    í‚¤ì›Œë“œ: <strong>${candidate.keyword}</strong> |
                                    í‚¤ì›Œë“œ í¬í•¨: <span class="${keywordClass}">${candidate.keyword_included ? 'YES' : 'NO'}</span>
                                    <br>
                                    ì£¼ìš” ìœ ì‚¬ë„: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">ìƒì„¸ë³´ê¸°</button>
                                    <br>
                                    ì¶œí˜„íšŸìˆ˜: ${candidate.frequency}íšŒ |
                                    ì›ë³¸íŒì •: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>ëª¨ë“  ìœ ì‚¬ë„ ê³„ì‚° ê²°ê³¼:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>ë¶„ì„:</strong><br>
                                    â€¢ ìµœê³ ì : ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    â€¢ ìµœì €ì : ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    â€¢ í‰ê· : ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    â€¢ ë¶„ì‚°: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                    ${preprocessingComparisonHTML}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">ìŠ¹ì¸</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">ê±°ì ˆ</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id} | í‚¤ì›Œë“œ: "${result.keyword || result.expected_answer}"</h3>
                        <div class="expected" style="font-size: 0.95rem; line-height: 1.4; margin-top: 10px;">ì •ë‹µ: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }


    </script>
</body>
</html>


<!--
todo ì´ ë¸”ëŸ­ì˜ ì½”ë“œëŠ” í• ì¼ì„ ê¸°ë¡í•œ ê²ƒì´ë¥´ëª¨ í´ë¡œë“œê°€ ìˆ˜ì •í•˜ê±°ë‚˜ ì‚­ì œí•˜ë©´ ì•ˆë¨.
1. ì‚¬ìš©ì ë°œí™”ëŠ” "íŒ”ì ì´", "íŒ”ì ì´ ë¯¸ë¦¬", "íŒ”ì ì´ ë¯¸ë¦¬ë¯¸í„°" ë“± í•œê¸€í™”ëœ ìˆ«ì í‘œí˜„ì„ ì •ê·œí™”í•´ì„œ ìˆ«ìë¡œ ë°”ê¾¼ ë’¤ ë¹„êµí•˜ëŠ” ê²Œ ê°€ì¥ ì •í™•í•©ë‹ˆë‹¤.
2. 8.2mm > íŒ”ì ì´ë¯¸ë¦¬ ë¡œ ìˆ«ì> í•œê¸€ ì „ì²˜ë¦¬ ì œê±°í•´ì„œ ë¹„êµ
3. ì „ì²˜ë¦¬ ì›ë³¸ vs 1-3 vs 1-4 ë‹¨ê³„ë¥¼ í•˜ë˜, ì²´í¬ë°•ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ì–´ë–¤ ìœ ì‚¬ë„ ê²°ê³¼ë§Œ ë³¼ì§€ ì„ íƒí•  ìˆ˜ ìˆê³ , ì´ì— ë•Œë¼ openai api í˜¸ì¶œë„ ì¡°ì •í•  ìˆ˜ ìˆê²Œ ìˆ˜ì •
4. Step 3. ë‹¨ìœ„ ì •ê·œí™” ì—ì„œ mm ë¥¼ ë¯¸ë¦¬ë¡œ ë°”ê¾¸ëŠ”ê²Œ ì•„ë‹ˆë¼ mm ë¡œ ìœ ì§€í•˜ê±°ë‹ˆ, ì¸ì¹˜ë„ inch ë¡œ ë°”ê¿”ì•¼í•˜ëŠ”ê±° ì•„ë‹Œê°€
5. vectordb ì“°ê²Œë˜ë©´, ì´ë¯¸ ì„ë² ë”© ì–»ì€ ê°’ë“¤ì€ ì¤‘ë³µí•´ì„œ ì¡°íšŒí•˜ì§€ ì•Šë„ë¡ + ì²˜ë¦¬ëœ ì‚¬ìš©ì ë°œí™” ê°’ì€ ì¤‘ë³µ ì¡°íšŒí•˜ì§€ ì•Šë„ë¡ ë¡œì§ í•„ìš”
6. ì¼ì • ê¸°ì¤€ì˜ ìœ ì‚¬ë„ ì•„ë˜ì˜ ê²°ê³¼ëŠ” ì•„ì˜ˆ ìˆ¨ê²¨ì•¼í•˜ë‚˜?


-->
