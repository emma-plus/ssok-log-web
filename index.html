<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 분석 파이프라인 - 유사어 분석</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 AI 분석 파이프라인</h1>
            <p>유사어 후보 분석 및 승인/거절 관리 시스템</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="apiKey">OpenAI API 키</label>
                <input type="password" id="apiKey" placeholder="sk-..." value="">
            </div>

            <div class="input-group">
                <label>분석 데이터 타입</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="word" checked style="margin-right: 8px;flex: 1;">
                        단어
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="dataType" value="sentence" style="margin-right: 8px;flex: 1;">
                        문장
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>OpenAI API 사용</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="true" style="margin-right: 8px;flex: 1;">
                        사용
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="useOpenAI" value="false" checked style="margin-right: 8px;flex: 1;">
                        사용 안함 (전처리만)
                    </label>
                </div>

                <div id="openaiModelOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: none;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #e0e0e0;">
                        OpenAI 임베딩 모델 선택
                    </label>
                    <div style="display: flex; flex-direction: row; gap: 5px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-small" checked style="margin-right: 8px;">
                            text-embedding-3-small (기본, 빠름, 경제적)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="openaiModel" value="text-embedding-3-large" style="margin-right: 8px;">
                            text-embedding-3-large (더 정확, 느림, 비쌈)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * text-embedding-3-large는 더 높은 정확도를 제공하지만 비용과 처리 시간이 더 많이 소요됩니다.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label>전처리 옵션</label>
                <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="true" checked style="margin-right: 8px;flex: 1;">
                        전처리 활성화
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="radio" name="enablePreprocessing" value="false" style="margin-right: 8px;flex: 1;">
                        전처리 비활성화
                    </label>
                </div>

                <div id="preprocessingStageOptions" style="background: #404040; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                    <div style="color: #e0e0e0; font-size: 0.9rem; line-height: 1.5; margin-bottom: 15px;">
                        <strong>전처리 단계:</strong><br>
                        <span style="color: #4fc3f7;">Step 1:</span> 한글 숫자 → 아라비아 숫자 (일→1, 이→2, 팔→8 등)<br>
                        <span style="color: #4fc3f7;">Step 2:</span> 소수점 표현 정규화 (점/쩜→., 8점9→8.9)<br>
                        <span style="color: #4fc3f7;">Step 3:</span> 단위 정규화 (m→미터, %→퍼센트, g→그램 등)<br>
                        <span style="color: #4fc3f7;">Step 4:</span> 숫자 → 한글 변환 (8.9→팔점구, 4400→사천사백)
                    </div>

                    <div style="color: #e0e0e0; margin-bottom: 10px;">
                        <strong>분석할 전처리 단계 선택:</strong>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="original" checked style="margin-right: 8px;">
                            원본 (전처리 없음)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step13" checked style="margin-right: 8px;">
                            1-3단계 (숫자 유지)
                        </label>
                        <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                            <input type="checkbox" name="preprocessingStages" value="step14" checked style="margin-right: 8px;">
                            1-4단계 (한글 변환)
                        </label>
                    </div>
                    <div style="color: #888; font-size: 0.8rem; margin-top: 10px;">
                        * 선택된 단계들에 대해서만 임베딩을 계산하고 비교합니다. 최소 1개는 선택해야 합니다.
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label for="csvData">분석 데이터 (CSV/TSV 형식)</label>
                <textarea id="csvData" placeholder="단어 형태 - CSV: 47,6499,15,false,,WORD_SIMILARITY_PASS_FAIL_V2,,스냅드래곤 8,,스냅드래 곰파에&#10;단어 형태 - TSV: 1290	5643	15	FALSE		WORD_SIMILARITY_PASS_FAIL_V2		포토		안티&#10;&#10;문장 형태 - TSV: 521	3985	18.5	FALSE	설명	SENTENCE_SIMILARITY_PASS_FAIL_V2	안티딥보이스		원본문장		사용자답변문장"></textarea>
            </div>

            <div style="display: flex; align-items: center; gap: 15px;">
                <button class="btn" onclick="analyzeData()">분석 시작</button>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="debugLevel" style="color: #e0e0e0; font-weight: 600; white-space: nowrap;">로그 레벨:</label>
                    <select id="debugLevel" style="padding: 8px; border: 2px solid #555; border-radius: 8px; background: #3a3a3a; color: #e0e0e0; font-size: 14px;">
                        <option value="0">0: 기본</option>
                        <option value="1" selected>1: 상세</option>
                        <option value="2">2: 모든 로그</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <p>🔄 AI가 데이터를 분석 중입니다...</p>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-controls" style="margin-bottom: 20px; text-align: center;">
                <button class="btn" onclick="approveAll()" style="background: #27ae60; margin-right: 10px;">모두 승인</button>
                <button class="btn" onclick="rejectAll()" style="background: #e74c3c; margin-right: 10px;">모두 거절</button>
                <button class="btn" onclick="exportResults()" style="background: #9b59b6; margin-right: 10px;">JSON 내보내기</button>
                <button class="btn" onclick="exportExcel()" style="background: #2e7d32;">📊 엑셀 내보내기</button>
            </div>
            <div id="results"></div>
        </div>
    </div>

    <!-- SheetJS 라이브러리 (엑셀 생성용) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- config.js 모듈 로드 (키 설정) -->
    <script src="./config.js"></script>
    <!-- similarity.js 모듈 로드 -->
    <script src="./similarity.js"></script>
    <!-- preprocessing.js 모듈 로드 -->
    <script src="./preprocessing.js"></script>
    <!-- management.js 모듈 로드 (관리 기능) -->
    <script src="./management.js"></script>
    <script>
        let analysisResults = [];
        let approvalStatus = {};
        let originalInputData = []; // 원본 입력 데이터 저장

        // 디버그 레벨 설정 (0: 기본, 1: 상세, 2: 모든 로그)
        function getDebugLevel() {
            const debugSelect = document.getElementById('debugLevel');
            return debugSelect ? parseInt(debugSelect.value) : 2;
        }

        // 페이지 로드 시 config.js에서 API 키 자동 로드
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof CONFIG !== 'undefined' && CONFIG.OPENAI_API_KEY) {
                document.getElementById('apiKey').value = CONFIG.OPENAI_API_KEY;
                console.log('API 키가 config.js에서 자동으로 로드되었습니다.');
            }

            // 전처리 옵션 변경 시 단계 선택 표시/숨김
            const preprocessingRadios = document.querySelectorAll('input[name="enablePreprocessing"]');
            const stageOptions = document.getElementById('preprocessingStageOptions');

            function toggleStageOptions() {
                const isEnabled = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
                stageOptions.style.display = isEnabled ? 'block' : 'none';
            }

            preprocessingRadios.forEach(radio => {
                radio.addEventListener('change', toggleStageOptions);
            });

            // OpenAI API 사용 옵션 변경 시 모델 선택 표시/숨김
            const openaiRadios = document.querySelectorAll('input[name="useOpenAI"]');
            const modelOptions = document.getElementById('openaiModelOptions');

            function toggleModelOptions() {
                const isOpenAIEnabled = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
                modelOptions.style.display = isOpenAIEnabled ? 'block' : 'none';
            }

            openaiRadios.forEach(radio => {
                radio.addEventListener('change', toggleModelOptions);
            });

            // 초기 상태 설정
            toggleStageOptions();
            toggleModelOptions();
        });


        // CSV/TSV 단어 데이터를 파싱하는 함수
        function parseWordData(dataText, debugLevel = 2) {
            const lines = dataText.trim().split('\n');
            const data = [];
            originalInputData = []; // 원본 데이터 초기화

            // 카운터 변수들
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // 데이터 형태 자동 감지 (첫 번째 유효한 라인으로 판단)
            let delimiter = ','; // 기본값은 CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // 탭과 쉼표 개수를 세어서 더 많은 쪽으로 결정
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV 형태로 감지되었습니다.');
                    } else {
                        delimiter = ',';
                        console.log('CSV 형태로 감지되었습니다.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // 빈 줄 체크
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // 주석 라인 체크
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`주석 라인 건너뛰기: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        answer: parts[7].trim(),
                        user_answer: parts[9].trim()
                    });

                    // 원본 입력 데이터 저장
                    originalInputData.push({
                        row_number: originalInputData.length + 1,
                        id: parts[0]?.trim() || '',
                        user_id: parts[1]?.trim() || '',
                        data_type: 'word',
                        version: parts[2]?.trim() || '',
                        pass: parts[3]?.trim() || '',
                        fail_reason: parts[4]?.trim() || '',
                        prompt_type: parts[5]?.trim() || '',
                        keywords: parts[6]?.trim() || '',
                        word: parts[7]?.trim() || '',
                        sentence: parts[8]?.trim() || '',
                        user_response: parts[9]?.trim() || '',
                        parsing_status: '성공',
                        original_line: trimmedLine
                    });
                } else {
                    skippedInvalidLines++;
                    if (debugLevel >= 1) {
                        console.log(`유효하지 않은 라인 (컬럼 수 부족): ${trimmedLine}`);
                    }

                }
            }

            console.log('=== 파싱 결과 요약 ===');
            console.log(`전체 라인 수: ${totalLines}`);
            console.log(`성공적으로 파싱된 레코드: ${data.length}`);
            console.log(`건너뛴 빈 줄: ${skippedEmptyLines}`);
            console.log(`건너뛴 주석 라인: ${skippedCommentLines}`);
            console.log(`건너뛴 유효하지 않은 라인: ${skippedInvalidLines}`);
            console.log(`사용된 구분자: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // CSV/TSV 문장 데이터를 파싱하는 함수
        function parseSentenceData(dataText, debugLevel = 2) {
            const lines = dataText.trim().split('\n');
            const data = [];
            originalInputData = []; // 원본 데이터 초기화

            // 카운터 변수들
            let skippedEmptyLines = 0;
            let skippedCommentLines = 0;
            let skippedInvalidLines = 0;
            let totalLines = lines.length;

            // 데이터 형태 자동 감지 (첫 번째 유효한 라인으로 판단)
            let delimiter = ','; // 기본값은 CSV

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('--') && !trimmedLine.startsWith('-')) {
                    // 탭과 쉼표 개수를 세어서 더 많은 쪽으로 결정
                    const tabCount = (trimmedLine.match(/\t/g) || []).length;
                    const commaCount = (trimmedLine.match(/,/g) || []).length;

                    if (tabCount > commaCount) {
                        delimiter = '\t';
                        console.log('TSV 형태로 감지되었습니다.');
                    } else {
                        delimiter = ',';
                        console.log('CSV 형태로 감지되었습니다.');
                    }
                    break;
                }
            }

            for (const line of lines) {
                const trimmedLine = line.trim();

                // 빈 줄 체크
                if (!trimmedLine) {
                    skippedEmptyLines++;
                    continue;
                }

                // 주석 라인 체크
                if (trimmedLine.startsWith('--') || trimmedLine.startsWith('-')) {
                    skippedCommentLines++;
                    console.log(`주석 라인 건너뛰기: ${trimmedLine}`);
                    continue;
                }

                const parts = trimmedLine.split(delimiter);
                // 문장 데이터는 최소 10개 컬럼이 필요 (id, user_id, version, judge, description, type, keyword, empty, original_sentence, user_sentence)
                if (parts.length >= 10) {
                    data.push({
                        id: parts[0].trim(),
                        user_id: parts[1].trim(),
                        version: parts[2].trim(),
                        origin_judge: parts[3].trim().toLowerCase() === 'true',
                        description: parts[4].trim(),
                        type: parts[5].trim(),
                        keyword: parts[6].trim(),
                        empty1: parts[7].trim(),
                        answer: parts[8].trim(), // 원본 문장
                        user_answer: parts[9].trim() // 사용자 답변 문장
                    });

                    // 원본 입력 데이터 저장
                    originalInputData.push({
                        row_number: originalInputData.length + 1,
                        id: parts[0]?.trim() || '',
                        user_id: parts[1]?.trim() || '',
                        data_type: 'sentence',
                        version: parts[2]?.trim() || '',
                        pass: parts[3]?.trim() || '',
                        fail_reason: parts[4]?.trim() || '',
                        prompt_type: parts[5]?.trim() || '',
                        keywords: parts[6]?.trim() || '',
                        word: parts[7]?.trim() || '',
                        sentence: parts[8]?.trim() || '',
                        user_response: parts[9]?.trim() || '',
                        parsing_status: '성공',
                        original_line: trimmedLine
                    });
                } else {
                    skippedInvalidLines++;
                    if (debugLevel >= 1) {
                        console.log(`유효하지 않은 라인 (컬럼 수 부족): ${trimmedLine}`);
                    }
                }
            }

            console.log('=== 문장 데이터 파싱 결과 요약 ===');
            console.log(`전체 라인 수: ${totalLines}`);
            console.log(`성공적으로 파싱된 레코드: ${data.length}`);
            console.log(`건너뛴 빈 줄: ${skippedEmptyLines}`);
            console.log(`건너뛴 주석 라인: ${skippedCommentLines}`);
            console.log(`건너뛴 유효하지 않은 라인: ${skippedInvalidLines}`);
            console.log(`사용된 구분자: '${delimiter === '\t' ? 'TAB' : 'COMMA'}'`);
            console.log('====================');

            return data;
        }

        // 단어 데이터를 그룹핑하는 함수 (expected_answer별로 그룹핑)
        function groupWordData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer) continue;

                const key = row.answer;
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        candidates: []
                    };
                }

                // 중복 제거를 위해 기존 후보 중에서 같은 user_answer가 있는지 확인
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        similarity: 0, // 임베딩 계산 후 업데이트
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // 문장 데이터를 그룹핑하는 함수 (키워드별로 그룹핑)
        function groupSentenceData(data) {
            const grouped = {};

            for (const row of data) {
                if (!row.answer || !row.user_answer || !row.keyword) continue;

                const key = row.keyword; // 키워드로 그룹핑
                if (!grouped[key]) {
                    grouped[key] = {
                        expected_answer: row.answer,
                        keyword: row.keyword,
                        candidates: []
                    };
                }

                // 중복 제거를 위해 기존 후보 중에서 같은 user_answer가 있는지 확인
                const existingCandidate = grouped[key].candidates.find(c => c.candidate_word === row.user_answer);
                if (existingCandidate) {
                    existingCandidate.log_id.push(parseInt(row.user_id));
                    existingCandidate.frequency += 1;
                } else {
                    grouped[key].candidates.push({
                        log_id: [parseInt(row.user_id)],
                        candidate_word: row.user_answer,
                        keyword: row.keyword,
                        keyword_included: false, // 키워드 포함 여부 (나중에 계산)
                        similarity: 0, // 임베딩 계산 후 업데이트
                        origin_judge: row.origin_judge ? "true" : "false",
                        frequency: 1
                    });
                }
            }

            return Object.values(grouped);
        }

        // 키워드 유사도 검증 함수 (키워드가 문장에 포함되어 있는지 유사도로 확인)
        async function checkKeywordSimilarity(keyword, sentence, apiKey, threshold = 0.8) {
            try {
                // 키워드와 문장에서 키워드 부분을 추출하여 비교
                const keywordEmbedding = await getEmbedding(keyword, apiKey);

                // 문장을 단어로 분리하여 각 단어와 키워드의 유사도 확인
                const words = sentence.split(/\s+/);
                let maxSimilarity = 0;

                for (const word of words) {
                    const wordEmbedding = await getEmbedding(word.trim(), apiKey);
                    const similarity = fastCosineSimilarity(keywordEmbedding, wordEmbedding);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity >= threshold;
            } catch (error) {
                console.error('키워드 유사도 검증 오류:', error);
                // 오류 시 문자열 포함 여부로 대체
                return sentence.toLowerCase().includes(keyword.toLowerCase());
            }
        }

        // OpenAI 임베딩 API 호출 (단일 텍스트)
        async function getEmbedding(text, apiKey) {
            // todo 일단 주석
            // const response = await fetch('https://api.openai.com/v1/embeddings', {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json',
            //         'Authorization': `Bearer ${apiKey}`
            //     },
            //     body: JSON.stringify({
            //         // text-embedding-3-small
            //         // text-embedding-3-large
            //         model: 'text-embedding-3-small',
            //         input: text,
            //         dimensions: 1024  // 더 높은 차원으로 더 정확한 임베딩
            //     })
            // });

            if (!response.ok) {
                throw new Error(`OpenAI API 오류: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // 텍스트 배열 검증 및 정리 함수
        function validateAndCleanTexts(texts) {
            if (!texts || !Array.isArray(texts) || texts.length === 0) {
                throw new Error('유효한 텍스트 배열이 필요합니다.');
            }

            // 1단계: 기본 필터링
            const basicFiltered = texts
                .filter(text => text != null && typeof text === 'string' && text.trim().length > 0);

            // 2단계: 제어 문자 및 특수 문자 정리
            const cleanTexts = basicFiltered.map(text =>
                text.replace(/[\x00-\x1F\x7F]/g, '') // 제어 문자 제거
                .replace(/[^\w\s가-힣]/g, ' ') // 특수 문자를 공백으로 변경
                .trim()
            ).filter(text => text.length > 0);

            // 3단계: 토큰 길이 제한 (OpenAI 제한: 8192 토큰, 대략 8192 문자로 추정)
            const finalTexts = cleanTexts.filter(text =>
                text.length > 0 && text.length < 8192
            );

            if (finalTexts.length === 0) {
                throw new Error('유효한 텍스트가 없습니다.');
            }

            const removed = texts.length - finalTexts.length;
            if (removed > 0) {
                console.warn(`${removed}개의 유효하지 않은 텍스트가 제거되었습니다.`);
                console.log('제거 상세:', {
                    원본: texts.length,
                    기본필터링후: basicFiltered.length,
                    문자정리후: cleanTexts.length,
                    최종: finalTexts.length
                });
            }

            console.log('검증된 텍스트 샘플:', finalTexts.slice(0, 3));
            return finalTexts;
        }

        // 디버깅용 텍스트 배열 분석 함수
        function logTextAnalysis(validTexts) {
            console.log('=== 텍스트 배열 분석 ===');
            console.log('배열 타입:', Array.isArray(validTexts));
            console.log('배열 길이:', validTexts.length);

            // 각 텍스트의 타입과 길이 확인
            const textAnalysis = validTexts.slice(0, 10).map((text, index) => ({
                index,
                type: typeof text,
                length: text ? text.length : 0,
                isEmpty: text === '',
                isNull: text === null,
                isUndefined: text === undefined,
                content: text ? `"${text.substring(0, 50)}..."` : text
            }));
            console.log('처음 10개 텍스트 분석:', textAnalysis);

            // 빈 문자열이나 문제가 될 수 있는 텍스트 찾기
            const problematicTexts = validTexts.filter((text, index) => {
                return !text || typeof text !== 'string' || text.trim() === '';
            });

            if (problematicTexts.length > 0) {
                console.warn('문제가 될 수 있는 텍스트들:', problematicTexts);
            }
            console.log('========================');
        }

        // API 요청 페이로드 로깅 함수
        function logRequestPayload(requestPayload) {
            console.log('API 요청 페이로드 미리보기:', {
                model: requestPayload.model,
                inputType: Array.isArray(requestPayload.input),
                inputLength: requestPayload.input.length,
                dimensions: requestPayload.dimensions,
                firstThreeInputs: requestPayload.input.slice(0, 3)
            });
        }

        // API 오류 로깅 함수
        async function logApiError(response, requestPayload) {
            console.error('API 요청 실패!');
            console.error('응답 상태:', response.status);
            console.error('응답 헤더:', Object.fromEntries(response.headers.entries()));

            const errorText = await response.text();
            console.error('응답 본문 (텍스트):', errorText);

            let errorData;
            try {
                errorData = JSON.parse(errorText);
                console.error('파싱된 오류 데이터:', errorData);
            } catch (parseError) {
                console.error('응답을 JSON으로 파싱할 수 없음:', parseError);
                errorData = { message: errorText };
            }

            // 요청했던 데이터도 함께 로깅
            console.error('실패한 요청의 input 샘플 (처음 3개):', requestPayload.input.slice(0, 3));
            console.error('실패한 요청의 전체 페이로드:', {
                model: requestPayload.model,
                inputCount: requestPayload.input.length,
                dimensions: requestPayload.dimensions
            });

            return errorData;
        }

        // OpenAI 임베딩 API 배치 호출 (여러 텍스트를 배치 단위로 나누어 처리)
        async function getBatchEmbeddings(texts, apiKey, selectedModel = 'text-embedding-3-small') {
            // 1. 텍스트 검증 및 정리
            const validTexts = validateAndCleanTexts(texts);

            // 2. 디버깅 로그
            console.log('API를 통해 임베딩 데이터를 로드합니다...');
            console.log(`유효한 텍스트 ${validTexts.length}개:`, validTexts.slice(0, 5), '...');
            logTextAnalysis(validTexts);

            if (!validTexts || validTexts.length === 0) {
                throw new Error('전송할 유효한 텍스트가 없습니다.');
            }

            // 3. OpenAI API 배치 크기 제한 (최대 2048개)
            const BATCH_SIZE = 2048;
            const totalBatches = Math.ceil(validTexts.length / BATCH_SIZE);
            const allEmbeddings = [];

            console.log(`총 ${validTexts.length}개 텍스트를 ${totalBatches}개 배치로 나누어 처리합니다.`);

            // 4. 배치별로 순차 처리
            for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                const startIdx = batchIndex * BATCH_SIZE;
                const endIdx = Math.min(startIdx + BATCH_SIZE, validTexts.length);
                const batchTexts = validTexts.slice(startIdx, endIdx);

                console.log(`배치 ${batchIndex + 1}/${totalBatches}: ${batchTexts.length}개 텍스트 처리 중...`);

                const requestPayload = {
                    model: String(selectedModel).trim(),
                    input: batchTexts.map(String)
                };

                console.log(`배치 ${batchIndex + 1} 요청:`, {
                    모델: requestPayload.model,
                    입력개수: requestPayload.input.length,
                    샘플: requestPayload.input.slice(0, 3)
                });

                try {
                    // API 호출
                    const response = await fetch('https://api.openai.com/v1/embeddings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestPayload)
                    });

                    console.log(`배치 ${batchIndex + 1} API 응답 상태:`, response.status, response.statusText);

                    // 오류 처리
                    if (!response.ok) {
                        const errorData = await logApiError(response, requestPayload);
                        throw new Error(`배치 ${batchIndex + 1} OpenAI API 오류: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    // 성공 응답 처리
                    const data = await response.json();
                    const batchEmbeddings = data.data.map(item => item.embedding);

                    allEmbeddings.push(...batchEmbeddings);
                    console.log(`배치 ${batchIndex + 1} 완료: ${batchEmbeddings.length}개 임베딩 추가 (누적: ${allEmbeddings.length}개)`);

                    // 다음 배치 전에 잠시 대기 (API 레이트 리미트 고려)
                    if (batchIndex < totalBatches - 1) {
                        console.log('다음 배치 처리를 위해 1초 대기...');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                } catch (error) {
                    console.error(`배치 ${batchIndex + 1} 처리 중 오류:`, error);
                    throw error;
                }
            }

            console.log(`모든 배치 처리 완료: 총 ${allEmbeddings.length}개 임베딩 로드`);
            return allEmbeddings;
        }

        // 기존 함수들은 similarity.js로 이동됨

        // 메인 분석 함수
        async function analyzeData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const csvData = document.getElementById('csvData').value.trim();
            const dataType = document.querySelector('input[name="dataType"]:checked').value;
            const useOpenAI = document.querySelector('input[name="useOpenAI"]:checked').value === 'true';
            const selectedModel = document.querySelector('input[name="openaiModel"]:checked')?.value || 'text-embedding-3-small';
            const DEBUG_LEVEL = getDebugLevel();

            if (useOpenAI && !apiKey) {
                alert('OpenAI API를 사용하려면 API 키를 입력해주세요.');
                return;
            }

            if (!csvData) {
                alert('분석할 데이터를 입력해주세요.');
                return;
            }

            // 전처리 활성화된 경우 최소 1개 단계 선택 확인
            const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';
            if (enablePreprocessing) {
                const selectedStages = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                if (selectedStages.length === 0) {
                    alert('전처리가 활성화된 경우 최소 1개의 단계는 선택해야 합니다.');
                    return;
                }
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';

            try {
                // 1. 선택된 타입에 따라 데이터 파싱
                let parsedData;
                if (dataType === 'word') {
                    console.log('단어 데이터 파싱 시작...');
                    parsedData = parseWordData(csvData, DEBUG_LEVEL);
                } else if (dataType === 'sentence') {
                    console.log('문장 데이터 파싱 시작...');
                    parsedData = parseSentenceData(csvData, DEBUG_LEVEL);
                }
                console.log('파싱된 데이터:', JSON.stringify(parsedData));

                // 2. 선택된 타입에 따라 데이터 그룹핑
                let groupedData;
                if (dataType === 'word') {
                    groupedData = groupWordData(parsedData);
                } else if (dataType === 'sentence') {
                    groupedData = groupSentenceData(parsedData);
                }
                console.log('그룹핑된 데이터:', JSON.stringify(groupedData));

                // 3. 배치로 임베딩 계산 및 유사도 분석
                analysisResults = [];
                let idCounter = 1;

                // 모든 텍스트를 한 번에 수집
                const allTexts = [];
                const textIndexMap = new Map();
                let textIndex = 0;

                // 텍스트 유효성 검증 함수
                function isValidText(text) {
                    return text && typeof text === 'string' && text.trim().length > 0;
                }

                // UI에서 전처리 옵션 가져오기
                const enablePreprocessing = document.querySelector('input[name="enablePreprocessing"]:checked').value === 'true';

                // 선택된 전처리 단계들 가져오기
                const selectedStages = [];
                if (enablePreprocessing) {
                    const stageCheckboxes = document.querySelectorAll('input[name="preprocessingStages"]:checked');
                    stageCheckboxes.forEach(checkbox => {
                        selectedStages.push(checkbox.value);
                    });

                    // 최소 1개는 선택되어야 함
                    if (selectedStages.length === 0) {
                        alert('전처리가 활성화된 경우 최소 1개의 단계는 선택해야 합니다.');
                        return;
                    }
                } else {
                    selectedStages.push('original'); // 전처리 비활성화 시 원본만
                }

                console.log('전처리 설정:', { enablePreprocessing, selectedStages });

                // 중복 텍스트 관리를 위한 맵 (processedText -> embeddingIndex)
                const uniqueTexts = new Map();
                let duplicateCount = 0;

                //// 선택된 전처리 단계에 따른 텍스트 수집 시작
                /**
                 * 임베딩 생성을 위한 텍스트 수집 과정
                 *
                 * 1. 정답(expected_answer) 텍스트들을 선택된 전처리 단계별로 수집
                 * 2. 각 단계별로 전처리된 텍스트를 allTexts 배열에 추가
                 * 3. textIndexMap으로 나중에 임베딩을 찾을 수 있도록 인덱스 매핑
                 *
                 * 이렇게 수집된 정답 임베딩들은 나중에 사용자 발화와의 유사도 계산에서
                 * 기준점(reference point)으로 사용됨
                 */
                // 정답들을 선택된 단계에 따라 수집
                const expectedAnswers = groupedData.map(group => group.expected_answer);
                expectedAnswers.forEach(answer => {
                    if (isValidText(answer)) {
                        selectedStages.forEach(stage => {
                            let processedText;
                            let stageKey;

                            if (DEBUG_LEVEL >= 2) {
                                console.log('선택한 단계 stage : ', stage)
                            }

                            // 선택된 전처리 단계에 따라 정답 텍스트 변환
                            switch(stage) {
                                case 'original':
                                    processedText = answer.trim();
                                    stageKey = 'original';
                                    break;
                                case 'step13':
                                    processedText = TextPreprocessor.applyBasePreprocessing(answer.trim());
                                    stageKey = 'step13';
                                    break;
                                case 'step14':
                                    processedText = TextPreprocessor.preprocessLearningText(answer.trim(), DEBUG_LEVEL);
                                    stageKey = 'step14';
                                    break;
                                default:
                                    console.warn(`알 수 없는 전처리 단계: ${stage}`);
                                    return;
                            }

                            const keyMapping = `expected_${answer}_${stageKey}`;

                            // 중복 검사: 이미 동일한 전처리 결과가 있는지 확인
                            if (uniqueTexts.has(processedText)) {
                                // 중복된 텍스트인 경우, 기존 임베딩 인덱스 재사용
                                const existingIndex = uniqueTexts.get(processedText);
                                textIndexMap.set(keyMapping, existingIndex);
                                duplicateCount++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`정답 ${stage} 중복 감지: "${answer}" → "${processedText}" (기존 인덱스 ${existingIndex} 재사용)`);
                                }
                            } else {
                                // 새로운 텍스트인 경우, 임베딩 대상에 추가
                                allTexts.push(processedText);
                                uniqueTexts.set(processedText, textIndex);
                                textIndexMap.set(keyMapping, textIndex);
                                textIndex++;

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`정답 ${stage} 전처리: "${answer}" → "${processedText}" (새 인덱스 ${textIndex-1})`);
                                }
                            }
                        });
                    } else {
                        console.warn(`유효하지 않은 정답 텍스트:`, answer);
                    }
                });

                console.log('정답들 > 선택된 단계 전처리 적용 완료');

                /**
                 * 사용자 발화(후보) 텍스트들을 선택된 전처리 단계별로 수집
                 *
                 * 1. 각 정답 그룹의 후보들(사용자가 입력한 답변들)을 순회
                 * 2. 정답과 동일한 전처리 단계를 적용하여 공정한 비교 환경 조성
                 * 3. 각 후보의 전처리된 텍스트를 allTexts 배열에 추가
                 * 4. textIndexMap으로 나중에 임베딩을 찾을 수 있도록 인덱스 매핑
                 *
                 * 이렇게 수집된 후보 임베딩들은 나중에 해당 정답 임베딩과의
                 * 유사도(거리/방향) 계산에서 측정 대상으로 사용됨
                 */
                // 모든 후보 단어들도 선택된 단계에 따라 수집
                groupedData.forEach(group => {
                    group.candidates.forEach(candidate => {
                        if (isValidText(candidate.candidate_word)) {
                            selectedStages.forEach(stage => {
                                let processedText;
                                let stageKey;

                                // 정답과 동일한 전처리 단계를 적용하여 공정한 비교
                                switch(stage) {
                                    case 'original':
                                        processedText = candidate.candidate_word.trim();
                                        stageKey = 'original';
                                        break;
                                    case 'step13':
                                        processedText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word.trim());
                                        stageKey = 'step13';
                                        break;
                                    case 'step14':
                                        processedText = TextPreprocessor.preprocessLearningText(candidate.candidate_word.trim(), DEBUG_LEVEL);
                                        stageKey = 'step14';
                                        break;
                                    default:
                                        console.warn(`알 수 없는 전처리 단계: ${stage}`);
                                        return;
                                }

                                const keyMapping = `candidate_${group.expected_answer}_${candidate.candidate_word}_${stageKey}`;

                                // 중복 검사: 이미 동일한 전처리 결과가 있는지 확인
                                if (uniqueTexts.has(processedText)) {
                                    // 중복된 텍스트인 경우, 기존 임베딩 인덱스 재사용
                                    const existingIndex = uniqueTexts.get(processedText);
                                    textIndexMap.set(keyMapping, existingIndex);
                                    duplicateCount++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`후보 ${stage} 중복 감지: "${candidate.candidate_word}" → "${processedText}" (기존 인덱스 ${existingIndex} 재사용)`);
                                    }
                                } else {
                                    // 새로운 텍스트인 경우, 임베딩 대상에 추가
                                    allTexts.push(processedText);
                                    uniqueTexts.set(processedText, textIndex);
                                    textIndexMap.set(keyMapping, textIndex);
                                    textIndex++;

                                    if (DEBUG_LEVEL >= 2) {
                                        console.log(`후보 ${stage} 전처리: "${candidate.candidate_word}" → "${processedText}" (새 인덱스 ${textIndex-1})`);
                                    }
                                }
                            });
                        } else {
                            console.warn(`유효하지 않은 후보 텍스트:`, candidate.candidate_word);
                        }
                    });
                });
                console.log('모든 후보 단어들 > 선택된 단계 전처리 적용 완료');

                // 중복 제거 결과 로그 출력
                const totalRequested = textIndex + duplicateCount;
                console.log(`=== 중복 제거 최적화 결과 ===`);
                console.log(`총 요청된 텍스트: ${totalRequested}개`);
                console.log(`중복 제거된 텍스트: ${duplicateCount}개`);
                console.log(`실제 임베딩 처리 텍스트: ${allTexts.length}개`);
                console.log(`API 호출 절약률: ${(duplicateCount / totalRequested * 100).toFixed(1)}%`);
                console.log('===============================');

                console.log(`총 ${allTexts.length}개 유효한 텍스트를 배치로 임베딩 처리합니다.`);
                console.log('전처리된 텍스트들:', allTexts.slice(0, 10).map((text, i) => `${i}: "${text}"`), allTexts.length > 10 ? `... 외 ${allTexts.length - 10}개` : '');

                // 빈 텍스트가 있는지 최종 확인
                const emptyTexts = allTexts.filter(text => !text || text.trim().length === 0);
                if (emptyTexts.length > 0) {
                    console.error(`빈 텍스트 ${emptyTexts.length}개 발견:`, emptyTexts);
                    throw new Error(`유효하지 않은 텍스트가 ${emptyTexts.length}개 포함되어 있습니다.`);
                }

                // 배치 수 미리 계산
                const BATCH_SIZE = 2048; // getBatchEmbeddings와 동일한 값
                const expectedBatches = Math.ceil(allTexts.length / BATCH_SIZE);
                console.log(`=== 임베딩 배치 처리 예상 ===`);
                console.log(`총 텍스트 수: ${allTexts.length}개`);
                console.log(`배치 크기: ${BATCH_SIZE}개`);
                console.log(`예상 배치 수: ${expectedBatches}개`);
                if (expectedBatches > 1) {
                    console.log(`배치별 분할:`);
                    for (let i = 0; i < expectedBatches; i++) {
                        const startIdx = i * BATCH_SIZE;
                        const endIdx = Math.min(startIdx + BATCH_SIZE, allTexts.length);
                        const batchSize = endIdx - startIdx;
                        console.log(`  - 배치 ${i + 1}: ${batchSize}개 (${startIdx + 1}~${endIdx}번째)`);
                    }
                }
                console.log(`예상 처리 시간: 약 ${expectedBatches * 3}초 (배치당 대기시간 포함)`);
                console.log('==============================');

                console.log('전처리된 텍스트들:', allTexts);

                //// 전처리 끝

                // OpenAI API 사용 여부에 따라 분기 처리
                let allEmbeddings = [];
                if (useOpenAI) {
                    // OpenAI API를 통한 임베딩 계산
                    console.log(`OpenAI API (${selectedModel})를 통해 임베딩을 계산합니다...`);
                    allEmbeddings = await getBatchEmbeddings(allTexts, apiKey, selectedModel);
                } else {
                    // OpenAI API 없이 전처리만 수행 - 더미 임베딩 데이터 생성
                    console.log('전처리만 수행합니다. OpenAI API는 사용하지 않습니다.');

                    // 더미 임베딩 데이터 (모든 값이 0.5인 1024차원 벡터)
                    allEmbeddings = allTexts.map(() => new Array(1024).fill(0.5));
                }

                // console.log('임베딩 결과 = allEmbeddings : ', allEmbeddings)

                /**
                 * 유사도 계산 핵심 로직
                 *
                 * 이 부분이 전체 시스템의 핵심으로, 다음과 같은 과정을 거침:
                 * 1. 정답의 임베딩을 기준점(reference)으로 설정
                 * 2. 사용자 발화(후보)의 임베딩을 측정 대상(target)으로 설정
                 * 3. 두 벡터 간의 거리와 방향을 다양한 유사도 메트릭으로 계산
                 * 4. 가장 높은 유사도를 보이는 전처리 방법을 최적 방법으로 선택
                 *
                 * 유사도 계산 방식:
                 * - 코사인 유사도: 벡터 간의 각도(방향)를 측정 (0~1, 높을수록 유사)
                 * - 유클리디안 거리: 벡터 간의 직선 거리를 측정 (낮을수록 유사)
                 * - 기타 다양한 거리/유사도 메트릭 적용
                 */
                // 각 그룹에 대해 선택된 단계별 유사도 계산
                for (const group of groupedData) {
                    // 각 후보에 대해 유사도 계산
                    for (const candidate of group.candidates) {
                        // 전처리 비교 결과를 저장할 객체
                        candidate.preprocessingComparison = {};

                        // 선택된 각 단계에 대해 유사도 계산
                        const comparisonResults = [];

                        for (const stage of selectedStages) {
                            // 정답의 임베딩 벡터 가져오기 (기준점 역할)
                            const expectedEmbedding = allEmbeddings[textIndexMap.get(`expected_${group.expected_answer}_${stage}`)];
                            // 사용자 발화의 임베딩 벡터 가져오기 (측정 대상)
                            const candidateEmbedding = allEmbeddings[textIndexMap.get(`candidate_${group.expected_answer}_${candidate.candidate_word}_${stage}`)];

                            if (expectedEmbedding && candidateEmbedding) {
                                // 핵심: 정답 임베딩을 기준으로 사용자 발화와의 유사도 계산
                                // expectedEmbedding(기준점) vs candidateEmbedding(측정대상)
                                const similarities = SimilarityCalculator.calculateAllSimilarities(expectedEmbedding, candidateEmbedding);

                                // 각 단계별 텍스트 생성
                                let expectedText, candidateText;
                                switch(stage) {
                                    case 'original':
                                        expectedText = group.expected_answer;
                                        candidateText = candidate.candidate_word;
                                        break;
                                    case 'step13':
                                        expectedText = TextPreprocessor.applyBasePreprocessing(group.expected_answer);
                                        candidateText = TextPreprocessor.applyBasePreprocessing(candidate.candidate_word);
                                        break;
                                    case 'step14':
                                        expectedText = TextPreprocessor.preprocessLearningText(group.expected_answer);
                                        candidateText = TextPreprocessor.preprocessLearningText(candidate.candidate_word);
                                        break;
                                }

                                candidate.preprocessingComparison[stage] = {
                                    similarity: similarities.cosine,
                                    similarities: similarities,
                                    expectedText: expectedText,
                                    candidateText: candidateText
                                };

                                comparisonResults.push({
                                    name: stage,
                                    similarity: similarities.cosine,
                                    similarities: similarities
                                });

                                if (DEBUG_LEVEL >= 2) {
                                    console.log(`${group.expected_answer} vs ${candidate.candidate_word} (${stage}): ${similarities.cosine.toFixed(3)}`);
                                }

                                // 유사도가 너무 낮다면 디버깅 정보 출력
                                if (similarities.cosine < 0.3) {
                                    const expectedMag = SimilarityCalculator.vectorMagnitude(expectedEmbedding);
                                    const candidateMag = SimilarityCalculator.vectorMagnitude(candidateEmbedding);
                                    console.log(`낮은 유사도 감지 (${stage}):`, {
                                        expected: group.expected_answer,
                                        candidate: candidate.candidate_word,
                                        stage: stage,
                                        similarity: similarities.cosine,
                                        expectedMag: expectedMag.toFixed(6),
                                        candidateMag: candidateMag.toFixed(6)
                                    });
                                }
                            } else {
                                console.warn(`임베딩을 찾을 수 없음: ${stage} 단계`);
                            }
                        }

                        // 가장 높은 유사도를 기본으로 사용
                        if (comparisonResults.length > 0) {
                            const bestComparison = comparisonResults.sort((a, b) => b.similarity - a.similarity)[0];
                            candidate.similarities = bestComparison.similarities;
                            candidate.similarity = bestComparison.similarity;
                            candidate.bestPreprocessingMethod = bestComparison.name;
                        } else {
                            console.warn('유효한 비교 결과가 없습니다.');
                            candidate.similarities = {};
                            candidate.similarity = 0;
                            candidate.bestPreprocessingMethod = 'none';
                        }

                        // todo test - checkKeywordSimilarity 일단 패스
                        // // 문장 타입인 경우 키워드 포함 여부 확인
                        // if (dataType === 'sentence' && candidate.keyword) {
                        //     candidate.keyword_included = await checkKeywordSimilarity(candidate.keyword, candidate.candidate_word, apiKey);
                        // }

                    }

                    // 유사도와 빈도수로 정렬
                    group.candidates.sort((a, b) => {
                        if (b.similarity !== a.similarity) {
                            return b.similarity - a.similarity;
                        }
                        return b.frequency - a.frequency;
                    });

                    // 결과 구조 생성 (문장/단어 타입에 따라 다름)
                    const resultItem = {
                        id: idCounter++,
                        expected_answer: group.expected_answer,
                        candidates: group.candidates
                    };

                    if (dataType === 'sentence') {
                        resultItem.keyword = group.keyword;
                    }

                    analysisResults.push(resultItem);
                }

                console.log('결과 데이터:', JSON.stringify(analysisResults));
                // 4. 선택된 타입에 따라 결과 표시
                if (dataType === 'word') {
                    displayWordResults();
                } else if (dataType === 'sentence') {
                    displaySentenceResults();
                }

            } catch (error) {
                console.error('분석 중 오류:', error);
                document.getElementById('loading').innerHTML = `<div class="error">오류가 발생했습니다: ${error.message}</div>`;
            }
        }

        // 단어용 결과 표시 함수
        function displayWordResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // 유사도 상세 정보 생성
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    // 전처리 비교 결과 HTML 생성 (선택된 단계만)
                    let preprocessingComparisonHTML = '';
                    if (candidate.preprocessingComparison && Object.keys(candidate.preprocessingComparison).length > 0) {
                        const stageNames = {
                            'original': '원본',
                            'step13': '1-3단계',
                            'step14': '1-4단계'
                        };

                        preprocessingComparisonHTML = `
                            <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
                                <strong>전처리 비교 결과:</strong><br>
                                ${Object.keys(candidate.preprocessingComparison).map(stage => {
                                    const comparison = candidate.preprocessingComparison[stage];
                                    const stageName = stageNames[stage] || stage;
                                    const isBest = candidate.bestPreprocessingMethod === stage;
                                    return `
                                        <span class="similarity-method${isBest ? ' best' : ''}">${stageName}: ${comparison.similarity.toFixed(3)}</span>
                                        <span style="color: #888; font-size: 0.8rem;">
                                            ("${comparison.expectedText}" vs "${comparison.candidateText}")
                                        </span><br>
                                    `;
                                }).join('')}
                                ${candidate.bestPreprocessingMethod ? `
                                    <span style="color: #4fc3f7; font-weight: bold; margin-top: 5px; display: block;">
                                        최적 방법: ${stageNames[candidate.bestPreprocessingMethod] || candidate.bestPreprocessingMethod}
                                    </span>
                                ` : ''}
                            </div>
                        `;
                    }

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    주요 유사도: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">상세보기</button>
                                    <br>
                                    출현횟수: ${candidate.frequency}회 |
                                    원본판정: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>모든 유사도 계산 결과:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>분석:</strong><br>
                                    • 최고점: ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    • 최저점: ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    • 평균: ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    • 분산: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                    ${preprocessingComparisonHTML}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">승인</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">거절</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id}</h3>
                        <div class="expected">정답: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }

        // 문장용 결과 표시 함수
        function displaySentenceResults() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            analysisResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';

                const candidatesHTML = result.candidates.map(candidate => {
                    const similarityClass = candidate.similarity >= 0.8 ? 'similarity-high' :
                                           candidate.similarity >= 0.6 ? 'similarity-medium' : 'similarity-low';

                    const keywordClass = candidate.keyword_included ? 'similarity-high' : 'similarity-low';

                    const candidateId = `${result.id}_${candidate.candidate_word}`;
                    const status = approvalStatus[candidateId] || '';

                    // 유사도 상세 정보 생성
                    const similarities = candidate.similarities || {};
                    const analysis = SimilarityCalculator.analyzeSimilarities(similarities);

                    const similarityDetailsHTML = Object.keys(similarities).map(method => {
                        const value = similarities[method];
                        let className = 'similarity-method';
                        if (analysis.highest && method === analysis.highest.method) {
                            className += ' best';
                        } else if (analysis.lowest && method === analysis.lowest.method) {
                            className += ' worst';
                        }
                        return `<span class="${className}">${method}: ${value}</span>`;
                    }).join(' ');

                    // 전처리 비교 결과 HTML 생성 (선택된 단계만)
                    let preprocessingComparisonHTML = '';
                    if (candidate.preprocessingComparison && Object.keys(candidate.preprocessingComparison).length > 0) {
                        const stageNames = {
                            'original': '원본',
                            'step13': '1-3단계',
                            'step14': '1-4단계'
                        };

                        preprocessingComparisonHTML = `
                            <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
                                <strong>전처리 비교 결과:</strong><br>
                                ${Object.keys(candidate.preprocessingComparison).map(stage => {
                                    const comparison = candidate.preprocessingComparison[stage];
                                    const stageName = stageNames[stage] || stage;
                                    const isBest = candidate.bestPreprocessingMethod === stage;
                                    return `
                                        <span class="similarity-method${isBest ? ' best' : ''}">${stageName}: ${comparison.similarity.toFixed(3)}</span>
                                        <span style="color: #888; font-size: 0.8rem;">
                                            ("${comparison.expectedText}" vs "${comparison.candidateText}")
                                        </span><br>
                                    `;
                                }).join('')}
                                ${candidate.bestPreprocessingMethod ? `
                                    <span style="color: #4fc3f7; font-weight: bold; margin-top: 5px; display: block;">
                                        최적 방법: ${stageNames[candidate.bestPreprocessingMethod] || candidate.bestPreprocessingMethod}
                                    </span>
                                ` : ''}
                            </div>
                        `;
                    }

                    return `
                        <div class="candidate-item ${status}" id="candidate_${candidateId}">
                            <div class="candidate-info">
                                <div class="candidate-word" style="font-size: 0.95rem; line-height: 1.4;">${candidate.candidate_word}</div>
                                <div class="candidate-stats">
                                    Log ID: [${candidate.log_id.join(', ')}] |
                                    키워드: <strong>${candidate.keyword}</strong> |
                                    키워드 포함: <span class="${keywordClass}">${candidate.keyword_included ? 'YES' : 'NO'}</span>
                                    <br>
                                    주요 유사도: <span class="${similarityClass}">${candidate.similarity}</span>
                                    <button class="similarity-toggle" onclick="toggleSimilarityDetails('${candidateId}')">상세보기</button>
                                    <br>
                                    출현횟수: ${candidate.frequency}회 |
                                    원본판정: <span class="${candidate.origin_judge === 'true' ? 'similarity-high' : 'similarity-low'}">${candidate.origin_judge}</span>
                                </div>
                                <div class="similarity-details" id="similarity_${candidateId}" style="display: none;">
                                    <strong>모든 유사도 계산 결과:</strong><br>
                                    ${similarityDetailsHTML}
                                    <br><br>
                                    <strong>분석:</strong><br>
                                    • 최고점: ${analysis.highest ? `${analysis.highest.method} (${analysis.highest.value})` : 'N/A'}<br>
                                    • 최저점: ${analysis.lowest ? `${analysis.lowest.method} (${analysis.lowest.value})` : 'N/A'}<br>
                                    • 평균: ${analysis.average ? analysis.average.toFixed(3) : 'N/A'}<br>
                                    • 분산: ${analysis.variance ? analysis.variance.toFixed(3) : 'N/A'}
                                    ${preprocessingComparisonHTML}
                                </div>
                            </div>
                            <div class="candidate-actions">
                                <button class="btn-approve" onclick="approveCandidate('${candidateId}')">승인</button>
                                <button class="btn-reject" onclick="rejectCandidate('${candidateId}')">거절</button>
                            </div>
                        </div>
                    `;
                }).join('');

                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>ID: ${result.id} | 키워드: "${result.keyword || result.expected_answer}"</h3>
                        <div class="expected" style="font-size: 0.95rem; line-height: 1.4; margin-top: 10px;">정답: "${result.expected_answer}"</div>
                    </div>
                    <div class="candidates-list">
                        ${candidatesHTML}
                    </div>
                `;

                resultsContainer.appendChild(resultDiv);
            });
        }


    </script>
</body>
</html>


<!--
todo 이 블럭의 코드는 할일을 기록한 것이르모 클로드가 수정하거나 삭제하면 안됨.
1. 사용자 발화는 "팔점이", "팔점이 미리", "팔점이 미리미터" 등 한글화된 숫자 표현을 정규화해서 숫자로 바꾼 뒤 비교하는 게 가장 정확합니다.
2. 8.2mm > 팔점이미리 로 숫자> 한글 전처리 제거해서 비교
3. 전처리 원본 vs 1-3 vs 1-4 단계를 하되, 체크박스를 만들어서 어떤 유사도 결과만 볼지 선택할 수 있고, 이에 때라 openai api 호출도 조정할 수 있게 수정
4. Step 3. 단위 정규화 에서 mm 를 미리로 바꾸는게 아니라 mm 로 유지하거니, 인치도 inch 로 바꿔야하는거 아닌가
5. vectordb 쓰게되면, 이미 임베딩 얻은 값들은 중복해서 조회하지 않도록 + 처리된 사용자 발화 값은 중복 조회하지 않도록 로직 필요
6. 일정 기준의 유사도 아래의 결과는 아예 숨겨야하나?


-->
